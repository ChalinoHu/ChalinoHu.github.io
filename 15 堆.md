# 堆

手写一个堆（以小根堆为例）的相关操作：

1、插入一个数 :  `heap[++size];up(size)` 

2、求集合中的最小值 : `heap[1]`

3、删除最小值 : `heap[1] = heap[size--];down(1);`

4、删除任意一个元素 : `heap[x] = heap[size--];down(x);up(x);`	这里down和up只有一个会执行

5、修改任意一个元素：`heap[x] = value;down(x);up(x)`

**堆**的底层实现是一颗**完全二叉树**，除了最后一层之外，上面所有的节点都是满的，最后一层从左往右排列。

**小根堆**：根节点始终是**小于等于**左右孩子节点，因此根节点是最小值。

**存储方式**：一般用**一维数组**来存，1号节点为根节点。x号节点的左儿子存储的位置在2x，右节点存储位置为2x + 1。

堆的相关操作：

1、`up（x）`向上调节堆：节点x和父节点比较大小，符合对应条件就与**父节点**进行交换，这个规程递归进行，直到不能调整为止。

2、`down(x)` 向下调节堆：节点x与孩子节点比较大小，并于符合条件的**孩子节点**交换位置，递归进行，直到不能调整。

## 代码模板：

```c++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

## 例题：堆排序

输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。

**输入格式**

第一行包含整数 n 和 m。

第二行包含 n 个整数，表示整数数列。

**输出格式**

共一行，包含 m 个整数，表示整数数列中前 m 小的数。

**数据范围**

1≤m≤n≤10^5，
1≤数列中元素≤10^9

**输入样例**：

```
5 3
4 5 1 3 2
```

**输出样例**：

```
1 2 3
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int h[N], n, m, length;

void down(int u){
    int t = u;
    if (2 * u <= length && h[2 * u] < h[t]) t = 2 * u;
    if (2 * u + 1 <= length && h[2 * u + 1] < h[t]) t = 2 * u + 1;
    // 两个if依次比较，找到最小的元素。
   if (t != u){
       swap(h[t], h[u]);
       down(t);
   }
}


void up(int u){
    while(u / 2 && h[u] < h[u / 2]){
        swap(h[u], h[u / 2]);
        u /= 2;
    }
}


int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) cin >> h[i];
    length = n;
    
    // 堆的初始化，时间复杂度为O(n)
    for (int i = n/2; i; i--) down(i);
    
    while(m--){
        cout << h[1] << " ";
        h[1] = h[length--];
        down(1);
    }
    cout << endl;
    return 0;
}
```

