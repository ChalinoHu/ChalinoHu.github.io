# 线性DP

[toc]

### 例题：数字三角形

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

**输入格式**

第一行包含整数 n，表示数字三角形的层数。

接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

**输出格式**

输出一个整数，表示最大的路径数字和。

**数据范围**

1≤n≤500,
−10000≤三角形中的整数≤10000

**输入样例**：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

**输出样例**：

```
30
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 510;
int a[N][N], f[N][N];
int n;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    
    // 一边输入一边输出
    for (int i = 0; i < n; i++){
        for (int j = 0; j <= i; j++){
            cin >> a[i][j];
            if (i){
                if (!j) a[i][j] += a[i - 1][j];
                else if (j == i) a[i][j] += a[i - 1][j - 1];
                else{
                    a[i][j] += max(a[i - 1][j], a[i - 1][j - 1]);
                }
            }
        }
    }
    cout << *max_element(a[n - 1], a[n - 1] + n) << endl;
    
    //先输入后输出
    // for (int i = 0; i < n; i++){
    //     for (int j = 0; j <= i; j++){
    //         cin >> a[i][j];
    //     }
    // }
    
    // for (int i = 0; i < n; i++){
    //     if (i){
    //         for (int j = 0; j <= i; j++){
    //             if (!j) a[i][j] += a[i - 1][j];
    //             else if (j == i) a[i][j] += a[i - 1][j - 1];
    //             else a[i][j] += max(a[i - 1][j], a[i - 1][j - 1]);
    //         }
    //     }
    // }
    //   cout << *max_element(a[n - 1], a[n - 1] + n) << endl;
    
    //先输入，从倒数第二增往上遍历
    // for (int i = 0; i < n; i++){
    //     for (int j = 0; j <= i; j++){
    //         cin >> a[i][j];
    //     }
    // }
    
    // for (int i = n - 2; i >= 0; i--){
    //     for (int j = 0; j <= i + 1; j++){
    //         a[i][j] += max(a[i + 1][j], a[i + 1][j + 1]);
    //     }
    // }
    
    // cout << a[0][0] << endl;
    
    
    
    return 0;
}
```

### 例题：最长上升子序列

给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

**输入格式**

第一行包含整数 N。

第二行包含 N 个整数，表示完整序列。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

1≤N≤1000，
−10^9≤数列中的数≤10^9

**输入样例**：

```
7
3 1 2 1 8 5 6
```

**输出样例**：

```
4
```

思路简述：

动态规划：

- 状态表示f[i]
  - 集合：所有以第i个数结尾的上升子序列
  - 属性：max
- 状态计算：f[i] = max(f[j]) + 1, j = 1...i - 1

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N], f[N];
int n;

int main(){
    cin >> n;
    for (int i = 0; i < n; i++){
        cin >> a[i];
        f[i] = 1;
        for (int j = 0; j < i; j++){
            if (a[i] > a[j] && f[i] < f[j] + 1) f[i] = f[j] + 1; 
        }
        
    }
    // for_each(f, f + n, [](int x){cout << x << " ";}), cout << endl;
    cout << *max_element(f, f + n) << endl;
    
    
    return 0;
}
```

### 例题：最长上升子序列II

如果数据范围改为 1≤N≤100000，朴素版动态规划做法会超时。

采用贪心策略，若我们找出长度为len的上升子序列的最小元素a，那么长度为len + 1的上升子序列结尾最小的元素b一定满足  a < b。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int n;


int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    vector<int> stk;
    
    for (int i = 0; i < n; i++){
        
        cin >> a[i];
        if (!i){
            stk.push_back(a[i]);
        }else {
            if (a[i] > stk.back()) stk.push_back(a[i]);
            else *lower_bound(stk.begin(), stk.end(), a[i]) = a[i];
        }
    }
    
    cout << stk.size() << endl;
   
    
    return 0;
}
```



### 例题：最长公共子序列

给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。

**输入格式**

第一行包含两个整数 N 和 M。

第二行包含一个长度为 N 的字符串，表示字符串 A。

第三行包含一个长度为 M 的字符串，表示字符串 B。

字符串均由小写字母构成。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

1≤N,M≤1000

**输入样例**：

```
4 5
acbd
abedc
```

**输出样例**：

```
3
```

**思路简要**：

- 动态规划：
  
  - 状态表示f[i, j]：
  
    - 集合：所有在第一个序列的前`i`个字母中出现，且在第二个序列的前`j`个字母中出现的序列
    - 属性：max（最大值）
  
  - 状态计算：
  
    是否选择第一个序列中的第i个字母以及是否选择第二个序列中的第j个字母，可以将状态划分为四种情况：（0， 0）（0， 1）（1，0）（1，1）
  
    状态的转移可以表示为四种情况的最大值：
  
    ```c++
    f[i, j] = max(f[i-1, j-1] + f[i - 1, j] + f[i, j - 1], f[i , j] + 1)
    ```
    
    其中f[i - 1, j]和f[i, j - 1]是包含f[i - 1, j - 1]的，因此只有后面的三种情况
  
    ```c++
    f[i, j] = max(f[i - 1, j] + f[i, j - 1], f[i , j] + 1)
    ```
    
    

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N][N];
char a[N], b[N];
int n, m;
int main(){
    
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i];
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```

### 例题：最短编辑距离

给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

1. 删除–将字符串 A 中的某个字符删除。
2. 插入–在字符串 A 的某个位置插入某个字符。
3. 替换–将字符串 A 中的某个字符替换为另一个字符。

现在请你求出，将 A 变为 B 至少需要进行多少次操作。

**输入格式**

第一行包含整数 n，表示字符串 A 的长度。

第二行包含一个长度为 n 的字符串 A。

第三行包含整数 m，表示字符串 B 的长度。

第四行包含一个长度为 m 的字符串 B。

字符串中均只包含大小写字母。

**输出格式**

输出一个整数，表示最少操作次数。

**数据范围**

1≤n,m≤1000

**输入样例**：

```
10 
AGTCTGACGC
11 
AGTAAGTAGGC
```

**输出样例**：

```
4
```

简要思路：

- 简要思路
  - 状态表示f[i, j]
    - 集合：将所有a[1...i]变成b[1...j]的操作方式
    - 属性： min
  - 状态计算
    - f[i, j]是由上一次操作之后，再通过删、增、改三种方式得到的，那么可通过查找上一次操作的最小次数，然后取三者最小的次数。
      - 若f[i, j]是由删除操作得到：f[i, j] = f[i - 1, j] + 1,（将a[1...i-1]变成b[1...j]的最小操作次数 加上这次的删除操作 1 次）
      - 若f[i, j]是由增添操作得到：f[i, j] = f[i, j - 1] + 1,（将a[1...i]变成b[1...j - 1]的最小操作次数加上这次的增添操作1 次）
      - 若f[i, j]是由替换操作得到：f[i, j] = f[i - 1, j -1] + 1 || 0,（将a[1...i-1]变成b[1...j-1]的最小次数加上这次的替换操作， 如果a[i]和b[j]相等则加0次，不等则需要替换，加1 次）

代码：

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main(){
        
    scanf("%d%s", &n, a + 1);
    scanf("%d%s", &m, b + 1);
    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;

    for (int i = 1; i <= n; i++) f[i][0] = i;
    for (int i = 1; i <= m; i++) f[0][i] = i;
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            f[i][j] = min({f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1] + (a[i] != b[j])});
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```
