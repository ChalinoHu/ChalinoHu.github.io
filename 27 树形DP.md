### 例题：没有上司的舞会

Ural 大学有 N 名职员，编号为 1∼N。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

**输入格式**

第一行一个整数 N。

接下来 N 行，第 i 行表示 i 号职员的快乐指数 Hi。

接下来 N−1 行，每行输入一对整数 L,K，表示 K 是 L 的直接上司。

**输出格式**

输出最大的快乐指数。

**数据范围**

1≤N≤6000,
−128≤Hi≤127

**输入样例**：

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

**输出样例**：

```
5
```

简要思路：

- 动态规划：

  - 状态表示

    - f[u, 0]
      - 集合：所有从根为u的子树中选，并且**不选u**这个点的方案
      - 属性：max
    - f[u, 1]
      - 集合：所有从根为u的子树中选，并且**选择u**这个点的方案
      - 属性：max

  - 状态计算

    - ```
      // 若j为以u为节点的所有儿子
      f[u][0] = max(f[j][0], f[j][1])
      f[u][1] = sum(f[j][0]) + a[u]
      ```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 6010;
int happy[N];
int h[N], e[N], ne[N], idx;
int f[N][2];
bool has_father[N]; // 记录每个节点是否有父节点
int n;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dfs(int u){
    
    f[u][1] = happy[u]; // 选择包含u的子树 
    
    for (int i = h[u]; i != -1; i = ne[i]){ // 遍历所有儿子
        int j = e[i];
        
        dfs(j);     // 计算子树状态
        
        f[u][0] += max(f[j][0], f[j][1]);
        f[u][1] += f[j][0];
    }
}

int main(){
    
    memset(h, -1, sizeof h);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> happy[i];
    
    for (int i = 0; i < n - 1; i++){
        int a, b;
        cin >> a >> b;
        has_father[a] = true;
        add(b, a);
    }
    
    int root = 1;
    while (has_father[root]) root++;    //找到根节点
    
    dfs(root);  // 从跟节点出发开始dp
    
    cout << max(f[root][0], f[root][1]) << endl;
    
    return 0;
}
```

