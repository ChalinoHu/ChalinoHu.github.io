# 最小生成树和二分图

[TOC]



## 最小生成树：

### 朴素版prim算法

时间复杂度是 O(n^2+m), n 表示点数，m 表示边数

### 算法模板

```c++
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )	// 迭代n次，每次从不属于当前树的节点中找到距离生成树最短的点
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```

### 例题：prim算法求最小生成树

给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。

由 VV 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。

**输出格式**

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

**数据范围**

1≤n≤500,
1≤m≤10^5,
图中涉及边的边权的绝对值均不超过 10000。

**输入样例**：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

**输出样例**：

```
6
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 510, INF = 0x3f3f3f3f;
int n, m;
int g[N][N];
int dis[N];
bool vst[N];

int prim(){
    memset(dis, 0x3f, sizeof dis);
    
    int ans = 0;
    
    for (int i = 0; i < n; i++){
        
        int t = -1;
        for (int j = 1; j <= n; j++){
            if (!vst[j] && (t == -1 || dis[j] < dis[t])) t = j;
        }
        
        if (i && dis[t] == INF) return INF;
        if (i) ans += dis[t];
        vst[t] = true;
        
        for (int j = 1; j <= n; j++){
            dis[j] = min(dis[j], g[t][j]);
        }
    }
    
    return ans;
}


int main(){
    memset(g, 0x3f, sizeof g);
    cin >> n >> m;
    
    while (m--){
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    
    int ans = prim();
    
    if (ans == INF) cout << "impossible" << endl;
    else cout << ans << endl;
    
    return 0;
}
```

### kruskal算法

时间复杂度是 O(mlogm), n 表示点数，m 表示边数。

###  kruskal算法模板

```c++
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```

### 例题：Kruskal算法求最小生成树

给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。

由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。

**输出格式**

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

**数据范围**

1≤n≤10^5,
1≤m≤2∗10^5,
图中涉及边的边权的绝对值均不超过 1000。

**输入样例**：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

**输出样例**：

```
6
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int M = 200010;
int p[M];
int n, m;

struct Edge{
    int a, b, w;
    bool operator<(const Edge &W){
        return w < W.w;
    }
}edges[M];

int find(int x){
    return p[x] = (p[x] == x)? p[x]:find(p[x]);
}


int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 0; i < m; i++){
        int a, b, c;
        cin >> a >> b >> c;
        edges[i] = {a, b, c};
    }
    
    // 边按照权值排序
    sort(edges, edges + m);
    
    // 并查集初始化，每个结点单独成为一个集合
    for (int i = 0; i < m; i++) p[i] = i;
    
    int ans = 0, cnt = 0;
    for (int i = 0; i < m; i++){
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        
        a = find(a), b = find(b);	// 找到祖宗节点，并路径压缩优化上次加入到并查集的路径（加快查找的速度）
        
        //边(a, b)没有加入到当前的连通分支中
        if (a != b){
            p[b] = a;
            ans = ans + w;	
            cnt++;	//统计加入边的数量
        }
        
    }
    // n个结点有n - 1条边，小于n - 1表明无法构成最小生成树
    if (cnt < n - 1) cout << "impossible" << endl;
    else cout << ans << endl;
    
    
    return 0;
}
```

## 二分图

时间复杂度是 O(n+m), n 表示点数，m 表示边数

### 染色法判别二分图

```c++
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

### 例题：染色体判别二分图

给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。

请你判断这个图是否是二分图。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 mm 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。

**输出格式**

如果给定图是二分图，则输出 `Yes`，否则输出 `No`。

**数据范围**

1≤n,m≤10^5

**输入样例**：

```
4 4
1 3
1 4
2 3
2 4
```

**输出样例**：

```
Yes
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 100010, M = 200010;
int n, m;
int h[N], e[M], ne[M], idx;	// 邻接表相关属性
int color[N];	// 0表示为染色

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

// 染色过程中没有冲突
bool dfs(int u, int c){
    color[u] = c;
    
    for (int i = h[u]; i != -1; i = ne[i]){
        int j  =e[i];
        if (!color[j]){	// 若未染色，那么接着染色
            if (!dfs(j, 3 - c)) return false;
        }
        if (c == color[j]) return false;	// 相邻的点已经染色但是出现冲突
    }
    
    return true;
}

int main(){
    memset(h, -1, sizeof h);
    cin >> n >> m;
    
    while(m--){
        int u , v;
        cin >> u >> v;
        add(u, v), add(v, u);
    }
    
    bool flg = true;
    for(int i = 1; i <= n; i++){	// 确保每个点会检查到相邻点的染色情况
        if (!color[i]){
            if (!dfs(i, 1)){
                flg = false;
                break;
            }
        }
        
    }
    
    if (flg) cout << "Yes" << endl;
    else cout << "No" << endl;
    
    return 0;
}
```

## 匈牙利算法

时间复杂度是 O(nm), n 表示点数，m 表示边数

### 代码模板

```c++
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```



### 例题：二分图的最大匹配

给定一个二分图，其中左半部包含 `n1` 个点（编号 `1∼n1`），右半部包含 `n2` 个点（编号 `1∼n2`），二分图共包含 mm 条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E}{E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。

二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

**输入格式**

第一行包含三个整数 n1、 n2 和 m。

接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。

**输出格式**

输出一个整数，表示二分图的最大匹配数。

**数据范围**

1≤n1,n2≤500,
1≤u≤n1,
1≤v≤n2,
1≤m≤10^5

**输入样例**：

```
2 2 4
1 1
1 2
2 1
2 2
```

**输出样例**：

```
2
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 510, M = 1e5 + 10;
int h[N], e[M], ne[M], idx;
int match[N];
bool vst[N];
int n1, n2, m;
void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int find(int u){
    for (int i = h[u];  i != -1; i = ne[i]){
        int j = e[i];
        if (!vst[j]){
            vst[j] = true;
            if (match[j] == 0 || find(match[j])){
                match[j] = u;
                return true;
            }
        }
    }
    return false;
}

int main(){
    memset(h, -1, sizeof h);
    cin >> n1 >> n2 >> m;
    while (m--){
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    
    int ans = 0;
    for (int i = 1; i <= n1; i++){
        memset(vst, false, sizeof vst);
        if (find(i)) ans++;
    }
    
    cout << ans << endl;
    return 0;
}
```

