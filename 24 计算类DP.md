[toc]



## 例题：整数划分

一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数 n 的一种划分。

现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。

**输入格式**

共一行，包含一个整数 n。

**输出格式**

共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 10^9+7 取模。

**数据范围**

1≤n≤1000

**输入样例**:

```
5
```

**输出样例**：

```
7
```

### 简要思路（一）：

完全背包问题：

- 状态表示`f[i][j]`

  - 集合：所有从1到i中选，和为j的选法
  - 属性：选法的数量

- 状态计算

  - ```
    f[i][j] = f[i-1][j]+f[i-1][j-i]+f[i-1][j-2*i]+...+f[i-1][j-s*i]	# 选择i的选法个数
    f[i][j-i]=			f[i-1][j-i]+f[i-1][j-2*i]+...+f[i-1][j-s*i]	# 选择一次i的选法个数，这里的s是一样的，因为都要满足两个式子都要满足j-s*i>=0
    ```

    ```
    f[i][j] = f[i][j - i] + f[i - 1][j] 
    状态压缩转换为：
    f[j] = f[j] + f[j - i]
    滚动数组, j从小到大遍历
    ```

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010, mod = 1e9 + 7;
int f[N], n;

int main(){
    cin >> n;
    f[0] = 1;
    for (int i = 1; i <= n; i++){
        for (int j = i; j <= n; j++){
            f[j] = (f[j] + f[j - i]) % mod;
        }
    }
    
    cout << f[n] << endl;
    
    return 0;
}


```

### 简要思路（二）

- 动态规划：
  - 状态表示`f[i][j]`
    - 集合：表示所有总和是i，并且恰好表示成j个数的和的方案
    - 属性：数量
  - 状态计算：
    `f[i][j]`可以通过两种状态得到：
    - 表示的j个数最小值为1
      - 这个集合减去一个1，那么状态可以表示成`f[i - 1][j - 1]`
    - 表示的j个数中最小值大于1
      - 集合中的每个数都减去一个1，那么状态可以表示成`f[i - j,j]`每个数都减去一个1，但是集合的个数不变

状态方程：

```
f[i][j] = f[i - 1][j -1] + f[i - j][j]
ans = f[n, 1] + f[n, 2] + f[n, 3] + ... + f[n, n]
```

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010, mod = 1e9 + 7;
int f[N][N], n;

int main(){
    cin >> n;
    f[0][0] = 1;
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= i; j++){
            f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod;
        }
    }
    
    int ans = 0;
    for (int i = 1; i <= n; i++) ans = (ans +f[n][i]) % mod;
    
    cout << ans << endl;
    
    return 0;
}
```

