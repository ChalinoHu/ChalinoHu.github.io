所谓的状态压缩DP，就是用二进制数来保存状态，使用二进制数而不是数组是为了能够更方便的做位运算。

### 例题：蒙德里安的梦想

求把 N×M 的棋盘分割成若干个 1×2的长方形，有多少种方案。

例如当 N=2，M=4 时，共有 5 种方案。当 N=2，M=3时，共有 3 种方案。

如下图所示：

![2411_1.jpg](https://www.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg)

**输入格式**

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 N 和 M。

当输入用例 N=0，M=0时，表示输入终止，且该用例无需处理。

**输出格式**

每个测试用例输出一个结果，每个结果占一行。

**数据范围**

1≤N,M≤11

**输入样例**：

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

**输出样例**：

```
1
0
1
2
3
5
144
51205
```

#### 简要思路：

将此问题看成在N * M的大方格中放2 * 1的小方格，当我们把所有横向的小方格放好之后，纵向小方格只有一种放法。那么整个大方格之后摆放小方格的方案数等价于在大方格中摆放横向的小方格的方案数。

横向摆放小方格的方案数：

`f[i][j]`表示第i列的第j个状态，j状态为1表示从上一列（第i-1列j行）开始横着摆放小格子，从而导致第j列有格子捅出来。	转移方程：本列的每一个状态都由上列的每一个合法状态转移而来，`f[i][j] += f[i - 1][k]`.

状态转移的两个条件：1、第i列和第i - 1列同一行不能同时捅出来；2、j和上一列的状态k做或运算不存在奇数个0，因为空出来的位置要留给纵向摆放的，小格子纵向摆放需要的位置肯定是连续的偶数个。

初始化条件：

​	`f[0][0] = 1`,第0列只能是状态0，没有任何格子捅出来；返回时`f[m][0]`,第m+1列不能有格子捅出来。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N  = 12, M  = 1 << N;
bool  st[M];	// 一列的某个状态是否会留下偶数个空0供小方竖着放
long long f[N][M];

int main(){
    int n, m;
    
    while (cin >> n >> m, n || m){
        // 预处理
        for (int i = 0; i < 1 << n; i++){   // 枚举一列的所有状态
            st[i] = true;
            int cnt = 0;
            for (int j = 0; j < n; j++){  // 枚举所有行
                if (i >> j & 1){
                    if (cnt & 1) st[i] = false;
                    cnt = 0;
                }
                else cnt++;
            }
            if (cnt & 1) st[i] = false;
        }
        
        // DP过程
        memset(f, 0, sizeof f);
        f[0][0] = 1;
        
        for (int i = 1; i <= m; i++) //枚举所有的列
            for (int j = 0; j < 1 << n; j++)    // 枚举列的所有状态
                for (int k = 0; k < 1 << n; k++)    // 前一列的状态
                    if ((j & k) == 0 && st[j | k])
                        f[i][j] += f[i - 1][k];
        
        cout << f[m][0] << endl;
    }
    
    return 0;
}
```

### 例题：最短Hamilton路径

给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。

Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。

**输入格式**

第一行输入整数 n。

接下来 n 行每行 n 个整数，其中第 i 行第 j 个整数表示点 i 到 j 的距离（记为 a[i,j]a[i,j]）。

对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x]并且 a[x,y]+a[y,z]≥a[x,z]。

**输出格式**

输出一个整数，表示最短 Hamilton 路径的长度。

**数据范围**

1≤n≤20
0≤a[i,j]≤10^7

**输入样例**：

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

**输出样例**：

```
18
```

简要思路：

动态规划：

- 状态表示`f[i][j]`
  - 集合：所有从0走到j，走过的所有点是i
  - 属性：min
- 状态计算

  假设当前j是从前一个点k走过来的，只要从k到j满足所有

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 20, M = 1 << N;

int n;
int w[N][N];
int f[M][N];

int main(){
    cin >> n;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            cin >> w[i][j];
        }
    }
    
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;	//从0号点到0号点的最短路径长度为0
    
    for (int i = 0; i < 1 << n; i++){  // 遍历所有状态
        for (int j = 0; j < n; j++){    // 遍历所有点
            if (i >> j & 1){    // 如果状态i中包含j	            
                for (int k = 0; k < n; k++){
                    if (i - (1 << j) >> k & 1){	// 不包含j的状态中包含k
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);
                    }
                }
            }
        }
    }
    
    cout << f[(1 << n) - 1][n - 1] << endl;
    
    return 0;
}
```

