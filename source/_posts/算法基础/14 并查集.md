---
title: 14 并查集
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 并查集

[toc]

## 简述

并查集的两个快速操作：

1、将两个集合合并。

2、询问两个元素是否在一个集合当中。

一般的暴力操作：将某个元素所在的集合存起来，如`belong[x] = a`，询问两个元素是否在同一个集合`if (belong[x] == belong[y])`, 但是将元素合并需要较高的时间复杂度。

并查集可在近乎O(1)的时间复杂度完成上述两个操作：合并和查询。

基本原理：以树的形式维护每个集合，树的根节点代表这颗树，也就代表着这个集合，在树的维护期间，每个节点记录着该节点的父节点，在进行查找时向上搜索，最终判断树根。如用p[x]存储x的父节点。

1、判断树根：`if (p[x] == x)`

2、求x的编号集合：`while(p[x] != x) x = p[x]`

3、两个集合的合并：如果`p_y`时集合y的编号，`p_x`是集合x的编号，那么两个结合合并可以写成p[p_y] = p_x（y并入x）或者p[p_x] = p_y（将x并入y）。

并查集的优化：元素在寻找根节点时，是不断查找自己的父节点，那么查找的次数是和树的高度成正比的。可使用**路径压缩**来对算法进行优化，第一次查找过后将所有的子节点直接指向根节点。

## 代码模板

(1)朴素并查集：

```c++
int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点
int find(int x)
{
	if (p[x] != x) p[x] = find(p[x]);
	return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
```


(2)维护size的并查集：

```c++
int p[N], size[N];
//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点
int find(int x)
{
	if (p[x] != x) p[x] = find(p[x]);
	return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
	p[i] = i;
	size[i] = 1;
}

// 合并a和b所在的两个集合：
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```


(3)维护到祖宗节点距离的并查集：

```c++
int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x)
{
	if (p[x] != x)
	{
		int u = find(p[x]);
		d[x] += d[p[x]];
		p[x] = u;
	}
    
	return p[x];
}

	// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
	p[i] = i;
	d[i] = 0;
}

	// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```



## 例题：合并集合

一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。

现在要进行 m 个操作，操作共有两种：

1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

**输入格式**

第一行输入整数 n 和 m。

接下来 m 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。

**输出格式**

对于每个询问指令 `Q a b`，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

**数据范围**

1≤n,m≤10^5

**输入样例**：

```
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
```

**输出样例**：

```
Yes
No
Yes
```

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int p[N], n, m;

int find(int x){
    if (x != p[x]) p[x] = find(p[x]);	// 递归寻寻找父节点，只有祖宗节点 x = p[x]
    								// p[x] = find(p[x]) 递归出栈时更新父节点，完成路径压缩
    return p[x];
}

int main(){
    int a, b;
    char mod;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) p[i] = i;	// 初始化，刚开始每个点都属于不同的集合
    while(m--){	// 处理询问
        cin >> mod;
        if (mod == 'M'){
            cin >> a >> b;
            p[find(a)] = find(b);	// ele[1]成为ele[0]的祖宗节点
        }else{
            cin >> a >> b;
            if (find(a) == find(b)) cout << "Yes" << endl;
            else cout << "No" << endl;
        }
    }
    
    return 0;
}
```



## 例题：连通块中点的数量

给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。

现在要进行 m 个操作，操作共有三种：

1. `C a b`，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
2. `Q1 a b`，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
3. `Q2 a`，询问点 a 所在连通块中点的数量；

**输入格式**

第一行输入整数 n 和 m。

接下来 m 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。

**输出格式**

对于每个询问指令 `Q1 a b`，如果 a 和 b 在同一个连通块中，则输出 `Yes`，否则输出 `No`。

对于每个询问指令 `Q2 a`，输出一个整数表示点 a 所在连通块中点的数量

每个结果占一行。

**数据范围**

1≤n,m≤10^5

**输入样例**：

```
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
```

**输出样例**：

```
Yes
2
3
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5;
int p[N], num[N], n, m;

int find(int x){
    return x == p[x]? x:(p[x] = find(p[x]));
}

int main(){
    
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) num[i] = 1, p[i] = i;
    
    while(m--){
        string mod;
        int a, b;
        
        cin >> mod;
        if (mod == "C"){
            cin >> a >> b;
            if (find(a) == find(b)) continue;
            
            // 先更新元素的个数，再进行合并，否则计算结果是合并后大集合总元素数量的2被
            num[find(b)] += num[find(a)];	// 更新集合中元素的个数
            p[find(a)] = find(b);			// 将两个集合合并
        }else if (mod == "Q1"){
            cin >> a >> b;
            if (find(a) == find(b)) cout << "Yes" << endl;
            else cout << "No" << endl;
        }else{
            cin >> a;
            cout << num[find(a)] << endl;
        }
    }
    
    return 0;
}
```

