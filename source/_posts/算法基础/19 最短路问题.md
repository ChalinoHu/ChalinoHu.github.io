---
title: 19 最短路问题
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 最短路问题

[TOC]

规定n为节点数，m为边数

- 单源最短路问题：一个点到其他所有点的最短距离
  - 边权都是正数
    - 朴素Dijkstra  	O(n^2)
    - 堆优化版Dijkstra    O(m * logn )
  - 边权含有负数
    - Bellman-Ford	O(n * m)
    - `SPFA` (一般：O(m), 最坏：O(n * m))
- 多源汇总最短路问题 : Floyd 		(O(n^3))



## 一、朴素dijkstra

1. 将所有的顶点分为两个部分：**已知最短距离的顶点集合P**和**未知最短距离的顶点集合Q**。最开始的时候，已知最短距离的顶点集合中只有源点。
2. 初始化distance数组，将源点s到自己的距离设置为0，到其他顶点的距离姑且设置为Infinity。
3. 依据distance数组，在未知顶点集合Q中选出距离源点最近的一个顶点u，放入P中，并考察所有以u为起点的边，以u作为中转点，检验是否能够减短源点到其他点的距离。如果有，就更新distance数组。这一步又叫松弛（relaxation）操作。

一般在边数量比较多的情况下用朴素`dijkstra`，因此存储的时候使用邻接矩阵来存储

### 朴素dijkstra模板

```c++
int g[N][N];  // 存储每条边
int dist[N];  // 存储u号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求u号点到n号点的最短路，如果不存在则返回-1
int dijkstra(int u)
{
    memset(dist, 0x3f, sizeof dist);
    dist[u] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }
    
    // 每个点到u号点的最短距离 dis

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



### 例题：Dijkstra求最短路 I

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

**输入格式**

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

**输出格式**

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

**数据范围**

1≤n≤500,
1≤m≤10^5,
图中涉及边长均不超过10000。

**输入样例**：

```
3 3
1 2 2
2 3 1
1 3 4
```

**输出样例**：

```
3
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 500 + 10;

int g[N][N];    // 边的权重
int dis[N];     // 各节点到1号节点的距离
bool vst[N];    // 是否被访问

int n,m;

int dijkstra(){
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0;
    
    for (int i = 0; i < n; i++){   // 迭代n次，寻找距离源点最短且没有访问过的点
    
        int t = -1;
        for (int j = 1; j <= n; j++){
            if (!vst[j] && (t == -1 || dis[j] < dis[t])){   // 找到相邻的最近的点
                t = j;
            }
        }
        vst[t] = true;  // 标记访问
        
        // 根据当前迭代找到的距离源点最短的点来更新dis
        for (int j = 1; j <= n; j++){
            dis[j] = min(dis[j], dis[t] + g[t][j]);  // 通过t来更新j的值
        }
    }
    
    if (dis[n] == 0x3f3f3f3f) return -1;
    return dis[n];
}

int main(){
    
    memset(g, 0x3f, sizeof g);
    
    cin >> n >> m;
    
    int a, b, x;
    for(int i = 0; i < m; i++){
        cin >> a >> b >> x;
        if (a == b) g[a][b] = 0;    // 自环
        g[a][b] = min(g[a][b], x);  // 重边，直接保存最短的那条边即可
        
    }
   
    cout << dijkstra() << endl;

    return 0;
}
```



## 二、堆优化版 dijkstra 算法

### 堆优化版模板

```c++
// 时间复杂度 O(mlogn), n 表示点数，m 表示边数

typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;
	
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



### 例题：Dijkstra求最短路 II

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。

请你求出 11 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

**输入格式**

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

**输出格式**

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

**数据范围**

1≤n,m≤1.5×10^5,
图中涉及边长均不小于 0，且不超过 10000。
数据保证：如果最短路存在，则最短路的长度不超过 10^9。

**输入样例**：

```
3 3
1 2 2
2 3 1
1 3 4
```

**输出样例**：

```
3
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6;

int h[N], e[N], ne[N], w[N], idx;
int dis[N];
bool vst[N];

int n, m;
typedef pair<int, int> PII;

priority_queue<PII, vector<PII>, greater<PII>> q;

void add(int a, int b, int c){
    e[idx] = b;
    ne[idx] = h[a];
    w[idx] = c;
    h[a] = idx++;
}

int dijkstra(){
    dis[1] = 0;
    q.push({0, 1});
    
    while(q.size()){
        
        auto t = q.top();
        q.pop();
        
        int ver = t.second, d = t.first;
        
        if (vst[ver]) continue;
        vst[ver] = true;
        
        for (int i = h[ver]; i != -1; i = ne[i]){
            int j = e[i];
            if (dis[j] > d + w[i]){
                dis[j] = d + w[i];
                q.push({dis[j], j});
            }
        }
    }
    
    if (dis[n] == 0x3f3f3f3f) return -1;
    return dis[n];
    
}

int main(){
    memset(h, -1, sizeof h);
    memset(dis, 0x3f, sizeof dis);
    
    cin >> n >> m;
    int a, b, c;
    while(m--){
        cin >> a >> b >> c;
        add(a, b, c);
    }
    cout << dijkstra() << endl;
    return 0;
}
```



## 三、bellman-ford算法

适用于含有负环的边，同时限定了最多经历边的条数。时间复杂度 O(nm), n 表示点数，m 表示边数

### bellman-ford模板

```c++
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```



### 例题：有边数限制的最短路

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出从 11 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 `impossible`。

注意：图中可能 **存在负权回路** 。

**输入格式**

第一行包含三个整数 n,m,k。

接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

**输出格式**

输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。

如果不存在满足条件的路径，则输出 `impossible`。

**数据范围**

1≤n,k≤500,
1≤m≤10000,
任意边长的绝对值不超过 10000。

**输入样例**：

```
3 3 1
1 2 1
2 3 1
1 3 3
```

**输出样例**：

```
3
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 510, M = 10010;

int n, m, k;
int dist[M], backup[M];

struct{
    int a, b, w;
}edges[M];


void bellman_ford(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for (int i = 0; i < k; i++){    // 经过边的条数
        memcpy(backup, dist, sizeof dist);	// 备份之后每次就只能走一条边
        for (int j = 0; j < m; j++){    // 根据每条边更新个顶点到源点的距离
            int a = edges[j].a, b = edges[j].b, w = edges[j].w; 
            dist[b] = min(dist[b], backup[a] + w);
        }
    }
    
    if (dist[n] > 0x3f3f3f3f / 2) cout << "impossible" <<endl;
    else cout << dist[n] << endl;
}

int main(){
    
    cin >> n >> m >> k;
    
    for (int i = 0; i < m; i++){
    cin >> edges[i].a >> edges[i].b >> edges[i].w;
    }
    bellman_ford();
    return 0;
}
```

## 四、spfa 算法（队列优化的Bellman-Ford算法）

时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数。

### spfa模板

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

### 例题：spfa求最短路

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 `impossible`。

数据保证不存在负权回路。

**输入格式**

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

**输出格式**

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 `impossible`。

**数据范围**

1≤n,m≤10^5,
图中涉及边长绝对值均不超过 10000。

**输入样例**：

```
3 3
1 2 5
2 3 -3
1 3 4
```

**输出样例**：

```
2
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, m;

int h[N], e[N], w[N], ne[N], idx;
bool vst[N];
int dis[N];

void add(int a, int b, int c){
    e[idx] = b;
    ne[idx] = h[a];
    w[idx] = c;
    h[a] = idx++;
}

void spfa(){
    queue<int> q;
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0;
    q.push(1);
    vst[1] = true;
    
    while(q.size()){
        int t = q.front();
        q.pop();
        
        vst[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (dis[j] > dis[t] + w[i]){
                dis[j] = dis[t] + w[i];
                if (!vst[j]){
                    q.push(j);
                    vst[j] = true;
                }
                
            }
        }
        
    }
    
    if (dis[n] == 0x3f3f3f3f) cout << "impossible" << endl;
    else cout << dis[n] << endl;
}
	
int main(){
    memset(h, -1, sizeof h);
    cin >> n >> m;
    int a, b, c;
    while (m--){
        cin >> a >> b >> c;
        add(a, b, c);
    }
    
    spfa();
    
    return 0;
}
```

## 五、floyd

求多源汇点最短路径问题，时间复杂度是 O(n^3), n 表示点数

### floyd模板

```c++
初始化：
for (int i = 1; i <= n; i ++ )
{
    for (int j = 1; j <= n; j ++ )
    {
        if (i == j) 
        {
            d[i][j] = 0;
		}
        else d[i][j] = INF;
    }
}

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```



### 例题：Floyd求最短路

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 `impossible`。

数据保证图中不存在负权回路。

**输入格式**

第一行包含三个整数 n,m,k。

接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点y 的有向边，边长为 z。

接下来 k 行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。

**输出格式**

共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 `impossible`。

**数据范围**

1≤n≤200,
1≤k≤n^2
1≤m≤20000
图中涉及边长绝对值均不超过 10000。

**输入样例**：

```
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
```

**输出样例**：

```
impossible
1
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 210, inf = 1e9;
int g[N][N];

void floyd(int n){
    for (int k = 1; k <= n; k++){
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= n; j++){
                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
            }
        }
    }
}


int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n, m, k;
    cin >> n >> m >> k;
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++){
            if (i == j) g[i][j] = 0;
            else g[i][j] = inf;
        }
    }
    
    int x, y, z;
    while (m--){
        cin >> x >> y >> z;
        g[x][y] = min(g[x][y], z);
    }
    
    floyd(n);
    
    int a, b;
    while(k--){
        cin >> a >> b;
        if (g[a][b] > inf / 2) cout << "impossible" << endl;
        else cout << g[a][b] << endl;
    }
    
    return 0;
}
```

