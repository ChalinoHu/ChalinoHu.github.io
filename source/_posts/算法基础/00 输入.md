---
title: 00 ACM模式数据输入问题
date: 2022-05-27 21:39:13
tags: 算法基础
---



# ACM模式的输入问题

# 输入一行空格相隔的数组

```cpp
auto nums = vector<int>();
while(cin >> tmp){
    nums.push_back(tmp);
    if (cin.get() == '\n') break;
}
```

一般定长输入，给定长度后循环输入即可；

# C++中的cin, cin.getline, getline等混合使用时不能输入直接执行下一行的问题

每次cin>>之后，缓冲区内会多出来一个回车符，这个回车符对cin>>不会有影响，但是对于cin.getline()函数和getline()函数就会产生影响，导致还不等你输入，就直接把输入语句执行语句运行结束了，直接去运行后面的程序了；解决方法就是养成习惯，每次cin>>之后，都加一句“cin.get();"或者“cin.ignore();”，而且这两句也不会影响连续多次cin>>的正常工作。

```c++
cin.get()
cin.ignore();s
```

不定长输入：

读入一行字符串，带有空格，需要转换为字符串数组

```c++
    int m;
    cin >> m;
    cin.get();	//	抵消缓冲符
    while (m--){

        auto s  = string();
        getline(cin, s);

        auto words = vector<string>();
        int last = 0;
        for (int i = 0; i < s.size(); i++){
            if (s[i] == ' ' && i != last) {
                    // cout << "i: " << i << " last: " << last << endl;
                    words.push_back(s.substr(last, i - last));
                    last = i + 1;
                }
        }
        words.push_back(s.substr(last, s.size() - last));

        cout << words.size() << endl;
        for_each(words.begin(), words.end(), [](auto x){cout << x << " ";}), cout << endl;
    }
```





C语言的多行输入问题， 求一个数组中最大值出现的次数，第一行输入一行数字，表示数组中的值，第二行输入数组的长度

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int N = 1000;	// 数组长度
const int M = 1000;	// 每个数的长度

int main(){

    int *q = (int*)malloc(sizeof(int) * N);
    char *buf = (char*)malloc(sizeof(char) * N);
    memset(q, 0, sizeof q);
    memset(buf, 0, sizeof buf);

    fgets(buf, N, stdin);
    int len = strlen(buf);

    int length;
    scanf("%d", &length);

    char *head = buf;
    int k = 0;
    for (int i = 0; i < len; i++){
        if (buf[i] == ' ' ){  
            q[k++] = atoi(head);
            head = &buf[i + 1];
        }
    }
    q[k++] = atoi(head);
    k = k <= length ? k : length;
	
    // 方法一：使用一个数记录最大值的出现次数
    int max = __INT_MAX__, ans;
    for (int i = 0; i < k; i++){
       if (!i || q[i] > max) max = q[i], ans = 1;
       else if (q[i] == max) ans++;
    }
    printf("%d %d", max, ans);
	
    // 方法二：使用哈希表存储每个数出现的次数，加M防止取到负数
    // int *umap = (int*)malloc(sizeof(int) * 2 * M);
    // memset(umap, 0, sizeof umap);
    // int max = q[0];
    // umap[q[0] + M]++;

    // for (int i = 1; i < k; i++){
    //     umap[q[i] + M]++;
    //     max = max > q[i] ? max : q[i];
    // }

    // printf("%d %d", max, umap[max + M]);
	// 如果值域比较大可使用离散化提高空间利用率，由于使用二分进行查找，查找时间复杂度变为O(logn)
    
    return 0;
}
```

以上代码可以使用离散值进行优化

