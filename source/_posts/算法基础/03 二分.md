---
title: 03 二分
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 整数二分与浮点二分



### 例题：数的范围

给定一个按照升序排列的长度为 n 的整数数组，以及 q个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 输入格式

第一行包含整数 n 和 q，表示数组长度和询问个数。

第二行包含 n 个整数（均在 1∼100001∼10000 范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

#### 输出格式

共q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 `-1 -1`。

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

const int N = 100000;
int q[N], n, m, k;
int start, end;

int main(){
    
	cin >> n >> m;
	for (int i = 0; i < n; ++i) cin >> q[i];
    
    while(m--){
        cin >> k;
        
        int l = 0, r = n-1;
        while(l < r){	//求左边界点
            int mid = l + r >> 1;
            if (q[mid] < k) l = mid + 1;
            else r = mid;
        }	/*end of while*/
        
        if(q[r] != k){	//这里l和r是相等的
            cout << "-1 -1" << endl;
            continue;
        }else{
            start = r;
            r = n-1;
            while(l < r){	//求右边界点
                int mid = l + r + 1>> 1;
                if(q[mid] > k) r = mid - 1;
                else l = mid;
            }
            end = r;
        }
        cout << start << " " << end<< endl;
    }	/*end of while*/
    
}	/*end of main*/
```

浮点二分和整数二分一样的模板，但是不用考虑整数的向下取整。

```c++
bool check(..);

while(l < r){
	int mid = (l + r) / 2;
    if (check(...)) l = mid;
    else r = mid;
}
```



之前的二分模板不好理解，这里插一个新的模板：

确定区间是**左闭右闭**的，保证我们查找的值在这个区间内。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;	// 解空间为[0, nums.size() - 1]
        // 左闭右闭
        while(l <= r){
            int mid = l + ((r - l) / 2);	// 防止计算溢出

            if (nums[mid] < target) l = mid + 1;
            else if (nums[mid] > target) r = mid - 1;
            else if (nums[mid] == target) return mid;
        }

        return -1;
    }
};
```

# 模板

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

```

浮点二分

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

