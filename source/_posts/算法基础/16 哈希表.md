---
title: 16 模拟哈希表
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 哈希表

## 一般哈希

### 代码模板

```c++
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```



首先需要找到一个比区间值大的质数，如果开的区间为100000，那么可通过以下代码寻找质数

```c++
for (int i = 100000; ; i++){

	bool flag = true;

	for (int j = 2; j < i; j++){
        if (i % j == 0){
            flag = false;
            break;
        }
    }

    if (flag){
        cout << i << endl;
        break;
    }
}
```



### 模拟散列表

维护一个集合，支持如下几种操作：

1. `I x`，插入一个数 xx；
2. `Q x`，询问数 xx 是否在集合中出现过；

现在要进行 N 次操作，对于每个询问操作输出对应的结果。

**输入格式**

第一行包含整数 N，表示操作数量。

接下来 N 行，每行包含一个操作指令，操作指令为 `I x`，`Q x` 中的一种。

**输出格式**

对于每个询问指令 `Q x`，输出一个询问结果，如果 xx 在集合中出现过，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

**数据范围**

1≤N≤10^5
−10^9≤x≤10^9

**输入样例**：

```
5
I 1
I 2
I 3
Q 2
Q 5
```

**输出样例**：

```
Yes
No
```

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 3;
int h[N], e[N], ne[N],idx;



void insert(int x){
    int k = ((x % N) + N) % N;  // 保证取模之后为正数
    e[idx] = x;		// 头插法解决哈希冲突
    ne[idx] = h[k];
    h[k] = idx++;
}


bool find(int x){
    int k = ((x % N) + N) % N;
    // 遍历链表
    for (int i = h[k]; i != -1; i = ne[i]){
        if (e[i] == x) return true;
    }
    return false;
}

int main(){
    
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    // 哈希表中存放的是链表的头节点
    // 由于采用静态链表，初始化-1代表 next==nullptr
    memset(h, -1, sizeof h);
    
    int m;
    cin >> m;
    while(m--){
        char mod;
        int x;
        cin >> mod >> x;
        if (mod == 'I'){
            insert(x);
        }else{
            if(find(x)) cout << "Yes" <<endl;
            else cout << "No" << endl;
        }
    }
    return 0;
}
```

使用开放寻址法来解决哈希冲突，出现冲突时接着访问下一个节点，直到找到坑位将这个数放进去。为了效率，一般开2~3个哈希区间。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 3;	//开多倍空间，更容易插入和查找
int h[N], null = 0x3f3f3f3f;

int find(int x){
    
    int k = (x % N + N) % N;
    // 循环一定能终止，因为开的有多余的空间，就算找到最后也没找到会让k从0开始寻找
    while(h[k] != x && h[k] != null){
        k++;
        if (k == N) k = 0;
    }
    // 找到可以插入的地方(null)或者x所在的位置
    // h[k] == x 表示找到x
    // h[k] == null 为可以插入的点
    return k;
}


int main(){
    
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    memset(h, 0x3f, sizeof h);
    
    int m;
    cin >> m;
    char mod;
    int x;
    while(m--){
        cin >> mod >> x;
        int k = find(x);
        if (mod == 'I') h[k] = x;
        else if (h[k] != null) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}
```

## 字符串哈希

核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

```c++
typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

