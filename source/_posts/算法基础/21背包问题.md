---
title: 21 背包问题
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 背包问题

[TOC]



## 01背包问题

### 题目

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 v_i价值是 w_i。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 v_i,w_i，用空格隔开，分别表示第 ii 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤1000
0<v_i,w_i≤1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例**：

```
8
```

### 思路

- 状态表示
  - 集合
    - 所有的选法
    - 条件
      - 只从前i个物品中选
      - 总体积不超过j
  - 属性
    - 最大、最小、数量
- 状态计算
  - 主要是集合划分f(i, j)
    - 不含i的集合：f(i - 1, j)
    - 含i的集合: max(f(i - 1, j), w_i + f(i - 1, j - v_i))

### 二维写法

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;
int f[N][N];
int v[N], w[N];
int n, m;

int main(){
    
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i++){
        for (int j = 0; j <= m; j++){
            f[i][j] = f[i - 1][j];
            if (j >= v[i]){
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            }
            
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```

化为一维：因为第i轮的结果只用到了第i-1论的结果，因此可以使用滚动数组降低状态保存数组的维数。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int w[N], v[N], f[N];
int n, m;

int main(){
    cin >> n >> m;    
    
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i++){
        // for(int j >= v[i]; j <= m; j++){
           	// f[j] = max(f[j], w[i] + f[j - v[i]]);   
 			// 	由于j-v[1]小于j，正序更新会导致同一层的f[j - v[i]在f[j]之前更新，
        	//	那么到f[j]更新时所用的f[j - v[i]]是第i层的f[j - v[i],
        	// 	即正序更新后还原二维状态转移方程为
       		// 	f[i][j] = max(f[i - 1][j], f[i][j - v[i])
        	//	与原二维状态转移方程不等价
        //}
        
        //倒序更新
        for (int j = m; j >= v[i]; j--){
            f[j] = max(f[j], w[i] + f[j - v[i]]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

由于整个过程是迭代式的，那么可以进一步在输入过程中进行优化：

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int w, v, f[N];
int n, m;

int main(){
    cin >> n >> m;    
    
    for (int i = 1; i <= n; i++){
        cin >> v >> w;
        for (int j = m; j >= v; j--){
            f[j] = max(f[j], f[j - v] + w);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

## 完全背包问题

### 题目

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 ii 种物品的体积是 v_i，价值是 w_i。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数N，V用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 v_i,w_i，用空格隔开，分别表示第 i 种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤1000
0<v_i,w_i≤1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例**：

```
10
```

### 朴素版写法：

和01背包不同的是，所有的物品都是可重复使用的，那么在集合的划分时需要划分多个集合，根据使用第i个物品的使用次数k来划分，但是k不是无限大的，要满足`j - k * w[i] >= 0` ，即`k * w[i] <= j`。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N][N], v[N], w[N]; 
int n, m;

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            for (int k = 0; k * v[i] <= j; k++)	// 进行集合的划分
            {
                f[i][j] = max(f[i][j], k * w[i] + f[i - 1][j - k * v[i]]);
            }
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

状态优化版

```
//			用0次				用1次				用2次					用k次
f[i][j] = max(f[i-1][j], f[i-1][j-v]+w, f[i-1][j-2*v]+2*w, ..., f[i-1][j-k*v]+k*w);
f[i][j-v] = 		 max(f[i-1][j-v],   f[i-1][j-2v]+w,...,     f[i-1][j-kv]+(k-1)w)
```

以上式子可进行转换

```
f[i][j] = max(f[i-1][j], f[i][j-v]+w)
```

这样在之前划分k个集合此时只需要划分两个集合就可以了。

优化版

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N][N], v[N], w[N]; 
int n, m;

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) f[i][j] = max(f[i-1][j], f[i][j - v[i]] + w[i]);   
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

### 状态压缩写法

多重背包在更新公式时，`f[i][j]`是由`f[i][j-v]`更新过来的，因此m在更新时需要从前往后顺序更新，确保使用的`f[j-v]`是已经被更新过的。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N], v[N], w[N]; 
int n, m;

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
    {
        for (int j = v[i]; j <= m; j++)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);   
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

## 多重背包问题

和完全背包类似，但是限定了每个物品使用的次数，如s[i]个物品使用的次数为s[i]。

这样每次在f[i, j]进行集合划分的时候，划分集合的数量为s[i] + 1（加1是因为不选这种情况，共0~s[i]种选法）,总的时间复杂度为O（n * v * s）

那么状态转移可以写为：

```
f[i, j] = max(f[i, j], f[i - 1, j - k * v[i]] + k * w[i]), 其中k = 0...s[i]
```

### 题目描述

有N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数N，V用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N≤1000
0<V≤2000
0<vi,wi,si≤2000

**提示**：

本题考查多重背包的二进制优化方法。

**输入样例**

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例**：

```
10
```

### 朴素版写法

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int s[N], v[N], w[N];
int n, m;
int f[N][N];
int main(){
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i];
    
    for (int i = 1; i <= n; i++){
        for (int j = 0; j <= m; j++){
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
            f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```

### 二进制优化写法

每个物品可以使用s次，那么我们可以将s使用二进制倍增的思想转化为log(s)个物品，每个物品只能使用一次。那么就可以将多重背包问题转换为01背包问题。时间复杂度为：n * v * log(s)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 25000, M = 2010;
int v[N], w[N], s[N], f[N];
int n, m;

int main(){
    cin >> n >> m;
    int cnt = 0;
    for (int i = 0; i < n; i++){
        int a, b, s;
        cin >> a >> b >> s;
        
        int k = 1;
        while (k <= s){
            ++cnt;
            v[cnt] = k * a;
            w[cnt] = k * b;
            s -= k;
            k *= 2;
        }
        if (s){
            ++cnt;
            v[cnt] = s * a;
            w[cnt] = s * b;
        }
    }
    
    n = cnt;
    
    for (int i = 1; i <= n; i++){
        for (int j = m; j >= v[i]; j--){
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout  << f[m] << endl;
    return 0;
}
```

可使用结构体写法，替换多个数组，和上述的思路一样，并且思路更清晰；

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2010;
int n, m;
int f[N];

struct good{
  int v, w;
};

int main(){
    
    cin >> n >> m;
    vector<good> goods;
    
    for (int i = 0; i < n; i++){
        int v, w, s;
        cin >> v >> w >> s;
        
        for (int k = 1; k <= s; k <<= 1){
            s -= k;
            goods.push_back({v * k, w * k});
        }
        if (s) goods.push_back({v * s, w * s});
    }
    
    
    for (auto good : goods){
        for (int j = m; j >= good.v; j--){
            f[j] = max(f[j], f[j - good.v] + good.w);
        }
    }
    
    cout << f[m] << endl;
    return 0;
}
```

## 分组背包问题

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

**输入格式**

第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
- 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤100
0<Si≤100
0<vij,wij≤100

**输入样例**

```
3 5
2
1 2
2 4
1
3 4
1
4 5
```

**输出样例**：

```
8
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int n, m;
int v[N][N], w[N][N], s[N];
int f[N];

int main(){
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++){
        cin >> s[i];
        
        for (int k = 1; k <= s[i]; k++){
            cin >> v[i][k] >> w[i][k];
        }
    }
    
    for (int i = 1; i <= n; i++){	
        for (int j = m; j >= 0; j--){	// 01背包问题，每组中的物品只能选择一个
            for (int k = 1; k <= s[i]; k++){	// 因为做了状态压缩，j和k的循环不能调换位置。
                //如果不做状态压缩，使用二维矩阵来做是没问题的
                // f[i][j] = max(f[i][j], f[i-1][j - v[i][k]]+w[i][k])
               	// 状态压缩后，调换位置后不能保证k中的物品只选择一个
                if (j >= v[i][k]) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }

    cout << f[m] << endl;
    
    
    return 0;
}
```

