---
title: 18 树和图的存储与遍历
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 树与图

[TOC]

## **DFS** 

递归查找

```c++
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

### 例题：平分物品



现在有n个物品，每一个物品都有一个价值，现在想将这些物品分给两个人，要求这两个人每一个人分到的物品的价值总和相同（个数可以不同，总价值相同即可），剩下的物品就需要扔掉，现在想知道最少需要扔多少价值的物品才能满足要求分给两个人。 

##### **输入描述:**

```
第一行输入一个整数 T，代表有 T 组测试数据。
对于每一组测试数据，一行输入一个整数 n ，代表物品的个数。接下来 n 个数，a[i] 代表每一个物品的价值。1<= T <= 101 <= n <= 151 <= a[i] <= 100000
```

##### **输出描述:**

```
对于每一组测试数据，输出一个答案代表最少需要扔的价值。
```

示例1

**输入**

```
1
5
30 60 5 15 30
```

**输出**

```
20
```

**说明**

```
样例解释，扔掉第三个和第四个物品，然后将第一个物品和第五个物品给第一个人，第二个物品给第二个人，每一个人分到的价值为60，扔掉的价值为20。
```



```c++
#include <bits/stdc++.h>
using namespace std;
const int N =15;
int a[N];
int t, n;
int ans = INT_MAX, sum;

void dfs(int a[], int pos, int a_re, int b_re){
    // a_re表示A收到的物品总价值, b_re表示B收到的物品总价值
    if (a_re == b_re) ans = min(ans, sum - 2 * a_re);
    if (pos == n) return;
    // 对于一个物品，有三种情况， 都不给， 给A， 给B
    dfs(a, pos + 1, a_re, b_re);
    dfs(a, pos + 1, a_re + a[pos], b_re);
    dfs(a, pos + 1, a_re, b_re + a[pos]);
}

int main(){
    
    cin >> t;
    while (t--){
        cin >> n;
        for (int i= 0 ; i < n; i++) cin >> a[i];
        sum = accumulate(a, a + n, 0);
        ans = INT_MAX;
        dfs(a, -1, 0, 0);
        cout << ans << endl;
    }
    
    return 0;
}
```

### 例题：岛屿问题

#### 岛屿数量

(https://leetcode.cn/problems/number-of-islands/)

```c++
class Solution {
public:

    void dfs(int i, int j, vector<vector<char>>& grid){
        grid[i][j] = '0';	// 相邻的区域都置为'0'，确保每个区间都只计算一次
        int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
        for (int dif = 0; dif < 4; dif++){
            int a = i + dx[dif], b = j + dy[dif];
            if (0 <= a && a < grid.size() && 0 <= b && b < grid[0].size() && grid[a][b] == '1') dfs(a, b, grid);
        }
    }

    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        for (int i = 0; i < grid.size(); i++){
            for (int j = 0; j < grid[0].size(); j++){
                if (grid[i][j] == '1'){
                    ans++;
                    dfs(i, j, grid);
                }
            }
        }
        return ans;
    }
};
```

岛屿最大面积

https://leetcode.cn/problems/max-area-of-island/

```c++
class Solution {
public:
    int dfs(int i, int j, vector<vector<int>>& grid){
        
        int ans = 1;
        grid[i][j] = 0;	//确保每块地皮只计算一次
        
        int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
        for (int dif = 0; dif < 4; dif++){
            int a = i + dx[dif], b = j + dy[dif];
            if (a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == 1) ans += dfs(a, b, grid);	// 遍历过程中计算岛屿面积
        }

        return ans;
    }

    int maxAreaOfIsland(vector<vector<int>>& grid) {

        int cnt = 0;
        for (int i = 0;  i < grid.size(); i++){
            for (int j = 0; j < grid[0].size(); j++){
                if (grid[i][j] == 1) {
                    cnt = max(cnt, dfs(i, j, grid));
                }
            }
        }

        return cnt;
    }
};
```

#### 机器人运动范围

(https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```c++
class Solution {
public:
    int getSum(int i, int j){
        auto s1 = to_string(i), s2 = to_string(j);
        int ans = 0;
        for (int i = 0, j = 0; i < s1.size() || j < s2.size(); i++, j++){
            if (i < s1.size()) ans += s1[i] - '0';
            if (j < s2.size()) ans += s2[j] - '0';
        }
        return ans;
    }

    int dfs(vector<vector<bool>> &vst, int i, int j, int m, int n, int k){
        
        if (i >= m || j >= n || getSum(i, j) > k || vst[i][j]) return 0;

        vst[i][j] = true;	// 每个点只计算一次
		// 机器人只能往下或者往右走
        return 1 + dfs(vst, i + 1, j, m, n, k) + dfs(vst, i, j + 1, m, n, k);

    }

    int movingCount(int m, int n, int k) {
        auto vst = vector<vector<bool>>(m, vector(n, false));
        return dfs(vst, 0, 0, m, n, k);
    }
};
```

#### 矩阵中的路径

(https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```c++
class Solution {
public:

    bool dfs(vector<vector<char>>& board, int i, int j, vector<vector<bool>>& vst, string word, int k){
        if (board[i][j] != word[k]) return false;   
        else if (k == word.size() - 1) return true;
        
        int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
        for (int dif = 0; dif < 4; ++dif){
            int a = i + dx[dif],  b = j + dy[dif];
            if (0 <= a && a <board.size() && 0 <= b && b < board[0].size() && !vst[a][b]){
                vst[a][b] = true;
                if (dfs(board, a, b, vst, word, k + 1)) return true;  // 找到了直接返回
                vst[a][b] = false;	// 如果没有要找的路径，需要还原现场
            }
        }

        return false;
    }

    bool exist(vector<vector<char>>& board, string word) {
        int row = board.size(), col = board[0].size();
        auto vst = vector<vector<bool>>(row, vector<bool>(col, false));
        for (int i = 0; i < row; i++){
            for (int j = 0; j < col; j++){
                vst[i][j] = true;
                if (dfs(board, i, j, vst, word, 0)) return true;  // 找到了直接返回
                vst[i][j] = false;
            }
        }

        return false;
    }
};
```



### 例题：排列数字

给定一个整数 n，将数字 1∼n排成一排，**将会有很多种排列方法**。

现在，请你按照字典序将所有的排列方法输出。

**输入格式**

共一行，包含一个整数 n。

**输出格式**

按字典序输出所有排列方案，每个方案占一行。

**数据范围**

1≤n≤7

**输入样例**：

```
3
```

**输出样例**：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 7 + 1;
int path[N];	// 存储一条路径，这个数组在dfs中是复用的
bool st[N];		// 存储一条路径中各个数字使用的状态，这个数组是复用的
int n;

// 每次深搜都是从第一位开始，直到搜索到最后一位。
void dfs(int u){
    
    // 搜索到最后一位，搜索结束
    if (u == n) {
        for (int i = 0; i < n; i++) cout << path[i] << " ";
        cout << endl;
        return;
    }
    
    // 树性结构开始分支
    for (int i = 1; i <= n; i++){
        if (!st[i]){
            path[u] = i;	// 存储结果
            st[i] = true;	// 条件标记，当前已经使用的数字下次排列就不能使用
            dfs(u + 1);		// 往下深搜
            st[i] = false;	// 恢复现场，在此步之前计算得到的排列方式已经输出了
        }
    }

}


int main(){
    cin >> n;
    
    dfs(0);
    
    return 0;
}
```

### 例题：N-皇后问题

n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

![](/images/image/19_860e00c489-1_597ec77c49-8-queens.png)

现在给定整数 n，请你输出所有的满足条件的棋子摆法。

**输入格式**

共一行，包含整数 n。

**输出格式**

每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。

其中 `.` 表示某一个位置的方格状态为空，`Q` 表示某一个位置的方格上摆着皇后。

每个方案输出完成后，输出一个空行。

**注意：行末不能有多余空格。**

输出方案的顺序任意，只要不重复且没有遗漏即可。

**数据范围**

1≤n≤9

**输入样例**：

```
4
```

**输出样例**：

```
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
```

#### 全排列思想做N皇后

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 20;

char g[N][N];   //存储一次排列的结果

bool col[N];    // 行是否可用标志
bool dg[N];     // 正对角线是否可用标志
bool udg[N];    // 反对角线是否可用标志

int n;

// 处理第0行
void dfs(int u){
    
    if (u == n) {
        for (int i = 0; i < n; i++) {
            puts(g[i]);
        }
        puts(" ");
        return;
    }
    
    for (int i = 0; i < n; i++)    // 遍历u行所有的列(i)
    	// 列，对角线和反对角线都可用
        if (!col[i] && !dg[i - u + n] && !udg[ u + i]){
            
            g[u][i] = 'Q';
            col[i] = dg[i - u + n] = udg[u + i] = true;
            dfs(u + 1);
            col[i] = dg[i - u + n] = udg[u + i] = false;	// 恢复现场
            g[u][i] = '.';	// 恢复现场
            
        }
        
}

int main(){
    
    cin >> n;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++) g[i][j] = '.';
    }
    
    dfs(0);
    
    return 0;
    
}
```

#### 基础思想

每个格子设置两个状态，“放”还是“不放“，按照从左往右，从上往下的路线进行遍历

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 20;
int n;
bool cow[N], col[N], dg[N], udg[N];
char g[N][N];


void dfs(int x, int y, int s){  // 坐标：行（x），列（y）和当前已经放到棋盘上的个数s
    
    if (y == n) y = 0, x++;	// y进行到最右边的后一个位置（边界是[0, n-1]），下一次转到下一行的第一个位置
    if (x == n){
        if (s == n){    
            for (int i = 0; i < n; i++) cout << g[i] << endl;
            cout << endl;
        }
        return;
    }
    
    // 不放
    dfs(x, y + 1, s);
    
    // 放
    if (!cow[x] && !col[y] && !dg[x + y] && !udg[x - y + n]){
        g[x][y] = 'Q';
        cow[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x, y + 1, s + 1);
        cow[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
        g[x][y] = '.';
    }
    
}

int main(){
    cin >> n;
    
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++){
           g[i][j] = '.'; 
        }
    
    dfs(0, 0, 0);
    return 0;
}
```

## bfs

头节点出队列，孩子节点入队列

```c++
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```



### 例题：走迷宫

给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。

数据保证 (1,1)处和 (n,m) 处的数字为 0，且一定至少存在一条通路。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。

**输出格式**

输出一个整数，表示从左上角移动至右下角的最少移动次数。

**数据范围**

1≤n,m≤100

**输入样例**：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

**输出样例**：

```
8
```

```c++
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int g[N][N];
int d[N][N];    // 该位置到(0, 0)的步数, -1表示该节点还未遍历过

PII q[N * N];

int n, m;


int bfs(){
    int hh = 0, tt = 0;
    q[0] = {0, 0};  // 初始坐标
    memset(d, -1, sizeof(d));
    d[0][0] = 0;    // 初始步长
    
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
    
    while(hh <= tt){    // 队列不为空
        auto t = q[hh++];
        for (int i = 0; i < 4; i++){    // 遍历4个方向
            int x = t.first + dx[i], y = t.second + dy[i];  // 计算新的坐标点
            
            if (0 <= x && x < n && 0 <= y && y < m && g[x][y] == 0 && d[x][y] == -1){
                d[x][y] = d[t.first][t.second] + 1;
                q[++tt] = {x, y};
            }
        }
    }
    
    return d[n -1][m - 1];

}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> m;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            cin >> g[i][j];
        }
    }
    
    cout << bfs() << endl;
    return 0;
}
```

## 树和图的存储与遍历

树与图的存储
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：`g[a][b]` 存储边a->b

(2) 邻接表

```c++
int N;			// 树（或图）的节点数
int M = 2 * N;	// 几个节点链表的总长度

int h[N];	// 每个节点维护的链表
memset(h, -1, sizeof h);	// 定义-1为链表空节点
int e[N], ne[N], idx;	//维护静态链表有关的元素 

// 有向图中加入一条边(a, b)
void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];	// 头插法
    h[a] = idx++;
}

// 深度遍历
bool vst[N];	// 记录节点是否被遍历
void dfs(int u){
    vst[u] = true;
    for(int i = h[a]; i != -1; i = ne[i]){	//遍历邻接表
        int j = e[i];
        if (!vst[j]) dfs(j);
    }
}

// 宽度优先遍历, 
int q[N];	// 队列
int d[N];	// 到u的距离
int bfs(int u){
    
    // 初始化， u节点入队列
    int hh = 0, tt = -1;
    q[++tt] = u;
    
    d[u] = 0;
    
    while(hh <= tt){
        int t = q[hh++];

        // 遍历相邻的节点
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            
            if (!d[j]){
                // 节点j没有被遍历过，就接着遍历，并入队列
                q[++tt] = j;
                d[j] = d[t] + 1;
            }
        }
        
    }
    
   return d[n];	// 返回n到u的最小步数
}

```



### 例题：树的重心

给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

**输入格式**

第一行包含整数 n，表示树的结点数。

接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。

**输出格式**

输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。

**数据范围**

1≤n≤10^5

**输入样例**

```
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```

**输出样例**：

```
4
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
const int M = N * 2;

int h[N];
int e[M], ne[M], idx;
bool vst[N];

int n;
int ans = N;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

// 返回以u为根节点的树的点数（包含u）
int dfs(int u){
    
    vst[u] =true;
    int sum = 1, res = 0;
    for (int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        if (!vst[j]){
            int s = dfs(j);
            sum += s;
            res = max(res, s);  //  找出子树最大的点数
        }
    }
    
    res = max(res, n - sum);    // 找到全局最大的点数
    ans = min(ans, res);        // 最大点数的最小值
    
    return sum;
}

int main(){
    
    memset(h, -1, sizeof h);
    
    cin >> n;
    int a, b;
    for (int i = 0; i < n; i++){
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}
```

### 例题：图中点的层次

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。

所有边的长度都是 1，点的编号为 1∼n。

请你求出 11 号点到 n 号点的最短距离，如果从 1 号点无法走到 n 号点，输出 −1−1。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到 b 的长度为 11 的边。

**输出格式**

输出一个整数，表示 11 号点到 n 号点的最短距离。

**数据范围**

1≤n,m≤10^5

**输入样例**：

```
4 5
1 2
2 3
3 4
1 3
1 4
```

**输出样例**：

```
1
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10, M = 2 * N;

int h[N];
int e[N], ne[N], idx;
bool vst[N];
queue<int> q;

int d[N];

int n, m;

void add(int a, int b){
    if (a == b) return;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int bfs(int u){
    
    q.push(u);
    d[1] = 0;
    
    while(!q.empty()){
        int t = q.front();
        q.pop();
        
        if (t == n) return d[t];
        
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            
            if (!d[j]){
                d[j] = d[t] + 1;
                q.push(j);
            }
        }
        
    }
    
   return -1;
}

int main(){
    
    memset(h, -1, sizeof h);
    
    cin >> n >> m;
    int a, b;
    for (int i = 0; i < m; i++){
        cin >> a >> b;
        add(a, b);
    }
    cout << bfs(1) << endl;
    return 0;
}
```

## 拓扑排序

时间复杂度  O(n+m), n 表示点数，m 表示边数

```c++
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```



### 例题：有向图的拓扑序列

给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。

若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。

**输出格式**

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出 −1。

**数据范围**

1≤n,m≤10^5

**输入样例**：

```
3 3
1 2
2 3
1 3
```

**输出样例**：

```
1 2 3
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int h[N], e[N], ne[N], idx;
int q[N], in[N];	// 使用队列来存储拓扑排序的顺序，in保存节点的入度
int n, m;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool topsort(){
    
    int hh = 0,  tt = -1;
    for (int i = 1; i <= n; i++){
        if (!in[i]) q[++tt] = i;
    }
    
    while(hh <= tt){
        int t = q[hh++];
        
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            in[j]--;
            if (!in[j]) q[++tt] = j;
        }
    }
    
    return tt == n - 1;
}


int main(){
    memset(h, -1, sizeof h);
    cin >> n >> m;
    int a, b;
    ios::sync_with_stdio(false);
    cin.tie(0);
    for (int i = 0; i < m; i++){
        cin >> a >> b;
        add(a, b);
        in[b]++;
    }
    
    if (topsort()){
        for (int i = 0; i < n; i++) cout << q[i] << " ";
        cout << endl;
    }else {
        cout << -1 << endl;
    }
    
    return 0;
}
```

