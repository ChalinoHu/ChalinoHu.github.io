---
title: 01 快速排序
date: 2022-05-27 21:39:13
tags: 算法基础
---



## 快排——边界问题

```c++
void quick_sort(int q[], int l, int r){
    if (l >= r) return;
    int x = q[l + r >> 1], i = l-1, j = r + 1;
    while(i < j){
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j+1, r);
}
```

#### 1 若选择的参考值为q[l]

```c++
    quick_sort(q, l, i-1);	//要确保i到不了左边界，否则会无限递归，可使用案例[3,1,2,4]验证
    quick_sort(q, i, r);
```



#### 2 若选择参考值为q[r]

```c++
quick_sort(q, l, j);	//要确保j到不了右边界，否则会无限递归
quick_sort(q, j+1, r);
```
#### 3 选择参考值为q[(l+r)/2]

由于我们是从左边往右边开始找元素进行比较，因此有可能会出现i到达左边界的情况，但是不会出现j在右边界的情况，也就是选择的元素是最大值，一遍排下来导致j出现在最右边。

## 快速选择算法

使用快速选择的思想，找出数组中第k小的数。

```c++
int quick_choice(int q[], int l, int r, int k){
    if (l >= r) return q[l];

    int x = q[l + r >> 1], i = l-1, j = r + 1;

    while(i < j){
        while(q[++i] < x);
        while(q[--j] > x);
        if (i < j) swap(q[i], q[j]);
    }
   	int sl = j-l+1;	//分治后左半部分的个数
    if (k <= sl) return quick_choice(q, l, j, k);
    else return quick_choice(q, j+1, r, k-sl);
}
```
由于每次选择时只需要对当前数组的一半进行划分，因此最终快速选择的时间复杂度为O(n)。

算法总体了类似二分的思想，递归最终的条件是找到该元素q[k-1]，此时递归不能进行划分，l和r都指向第k个大的元素q[k-1]（数组下标从0开始）。



## 快排模板

```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);

}
```

