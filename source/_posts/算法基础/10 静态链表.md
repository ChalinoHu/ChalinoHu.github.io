---
title: 10 静态链表
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 链表

使用数组来模拟单链表，即静态链表，算法题中使用静态链表不需要调用new申请内存，操作的速度快，静态链表中不考虑节点的回收，一切为了速度。

## 单链表

```c++
const int N = 10010;
// e[i] 存放的是节点i的值
// ne[i] 存放的是节点i的下一个节点
// idx当前使用的节点，不是cur,相当于新建立的一个节点
int e[N], ne[N], idx;
```

```c++
// 建立一个空的链表
void init(){
	head = -1;
    idx = 0;
}
```

```c++
// 在第k个节点后插入值为x的节点
void insert(int k, int x){
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx++;
}
```

```c++
// 删除下标是k的看下一个节点
void remove(int k){
    ne[k] = ne[ne[k]];
}

```

```c++
// 在头节点之前添加值为x的节点
void add_to_head(int x){
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx++;
}
```

### 例题

实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 k 个插入的数后面的数；
3. 在第 k 个插入的数后插入一个数。

现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `H x`，表示向链表头插入一个数 x。
2. `D k`，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
3. `I k x`，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。

#### 输出格式

共一行，将整个链表从头到尾输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
```

#### 输出样例：

```
6 4 6 5
```

题目中注明了所有的操作都是合法的，因此不用考虑杀出一个已经删除的数以及在一个不存在的元素后面进行插入。

```c++
#include <iostream>
using namespace std;

const int N = 100000;
int head, e[N], ne[N], idx;

// 初始化
void init(){
    head = -1;
    idx = 0;
}

// 在头节点插之后插入一个元素
void add_to_head(int x){
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx++;
}

// 在删除节点k后面的那个节点
void remove(int k){
    ne[k] = ne[ne[k]];
}

//在节点k的后面插入一个节点
void insert(int k, int x){
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}

int main(){
    
    char mode;
    int k, x;
    
    // 老忘记初始化
    init();
    int n;
    cin >> n;
    
    while(n--){
        
        cin >> mode;
        if (mode == 'I'){
            cin >> k >> x;
            insert(k-1 ,x);
        }else if (mode == 'D'){
            cin >> k;
            if (!k) head = ne[head];
            remove(k-1);
        }else if (mode == 'H'){
            cin >> x;
            add_to_head(x);
        }
    }
    
    
    for(int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;
    
    return 0;
}
```

## 双链表

```c++
const int N = 100000;
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

int m;

void init(){
    // 固定0表示双链表最左侧，或者左端点，1表示最右侧；
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

// 节点k的右边插入一个节点
void insert(int k, int x){
    e[idx] = x;
    l[idx] = k, r[idx] = r[k];
    r[l[idx]] = idx, l[r[idx]] = idx;
    idx++;
}

// 删除节点k
void remove(int k){
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}
```

例题：

实现一个双链表，双链表初始为空，支持 5 种操作：

1. 在最左侧插入一个数；
2. 在最右侧插入一个数；
3. 将第 k 个插入的数删除；
4. 在第 k 个插入的数左侧插入一个数；
5. 在第 k 个插入的数右侧插入一个数

现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `L x`，表示在链表的最左端插入数 x。
2. `R x`，表示在链表的最右端插入数 x。
3. `D k`，表示将第 k 个插入的数删除。
4. `IL k x`，表示在第 k 个插入的数左侧插入一个数。
5. `IR k x`，表示在第 k 个插入的数右侧插入一个数。

#### 输出格式

共一行，将整个链表从左到右输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
```

#### 输出样例：

```
8 7 7 3 2 9
```

```c++
#include <iostream>

using namespace std;

const int N = 100000;

int e[N], l[N], r[N], idx;

int m;

void init(){
    // 固定0表示双链表最左侧，或者左端点，1表示最右侧；
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

// 节点k的右边插入一个节点
void insert(int k, int x){
    e[idx] = x;
    l[idx] = k;
    r[idx] = r[k];
    r[l[idx]] = idx;
    l[r[idx]] = idx;
    idx++;
}

// 删除节点k
void remove(int k){
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main(){
    
    cin >> m;
    init();
    string mode;
    int k, x;
    
    while(m--){
        cin >> mode;
        
        int i_mode = 0;
        if (mode == "L") i_mode = 1;
        if (mode == "R") i_mode = 2;
        if (mode == "D") i_mode = 3;
        if (mode == "IL") i_mode = 4;
        if (mode == "IR") i_mode = 5;
        
        switch(i_mode){ // 本来是先写的switch，但是不支持字符串的匹配，哎，这段时间写python多了。索性留在这里吧，当个彩蛋。
            
            case 1:
            cin >> x;
                insert(0, x);
                break;
                
            case 2:
                cin >> x;
                insert(l[1], x);
                break;
            
            case 3:
                cin >> k;
                remove(k+1);
                break;
            
            case 4:
                cin >> k >> x;
                insert(l[k+1], x);
                break;
            
            case 5:
                cin >> k >> x;
                insert(k+1, x);
                break;
            
            default:
                break;
                
        }
    }
    
    for(int i = r[0]; i != 1; i = r[i]) cout << e[i] << ' ';
    cout << endl;
    
    return 0;
}
```

