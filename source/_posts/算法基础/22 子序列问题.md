---
title: 22 线性DP模型
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 线性DP

[toc]

## 数字三角形模型：

### 例题1：数字三角形

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

**输入格式**

第一行包含整数 n，表示数字三角形的层数。

接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

**输出格式**

输出一个整数，表示最大的路径数字和。

**数据范围**

1≤n≤500,
−10000≤三角形中的整数≤10000

**输入样例**：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

**输出样例**：

```
30
```

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 510;
int a[N][N], f[N][N];
int n;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    
    // 一边输入一边输出
    for (int i = 0; i < n; i++){
        for (int j = 0; j <= i; j++){
            cin >> a[i][j];
            if (i){
                if (!j) a[i][j] += a[i - 1][j];
                else if (j == i) a[i][j] += a[i - 1][j - 1];
                else{
                    a[i][j] += max(a[i - 1][j], a[i - 1][j - 1]);
                }
            }
        }
    }
    cout << *max_element(a[n - 1], a[n - 1] + n) << endl;
    
    //先输入后输出
    // for (int i = 0; i < n; i++){
    //     for (int j = 0; j <= i; j++){
    //         cin >> a[i][j];
    //     }
    // }
    
    // for (int i = 0; i < n; i++){
    //     if (i){
    //         for (int j = 0; j <= i; j++){
    //             if (!j) a[i][j] += a[i - 1][j];
    //             else if (j == i) a[i][j] += a[i - 1][j - 1];
    //             else a[i][j] += max(a[i - 1][j], a[i - 1][j - 1]);
    //         }
    //     }
    // }
    //   cout << *max_element(a[n - 1], a[n - 1] + n) << endl;
    
    //先输入，从倒数第二增往上遍历
    // for (int i = 0; i < n; i++){
    //     for (int j = 0; j <= i; j++){
    //         cin >> a[i][j];
    //     }
    // }
    
    // for (int i = n - 2; i >= 0; i--){
    //     for (int j = 0; j <= i + 1; j++){
    //         a[i][j] += max(a[i + 1][j], a[i + 1][j + 1]);
    //     }
    // }
    
    // cout << a[0][0] << endl;
    
    
    
    return 0;
}
```

### 例题2：摘花生

Hello Kitty想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。Hello Kitty只能向东或向南走，不能向西或向北走。问Hello Kitty最多能够摘到多少颗花生。

![1.gif](https://cdn.acwing.com/media/article/image/2019/09/12/19_a8509f26d5-1.gif)

**输入格式**

第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

**输出格式**

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

**数据范围**

1≤T≤100,
1≤R,C≤100,
0≤M≤1000

**输入样例**：

```
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

**输出样例**：

```
8
16
```

思路：

- 动态规划：
  - 状态表示f[i, j]
    - 集合:从(1,1)从(i, j)的所有路线
    - 属性：所有路线中的最大值
  - 状态计算
    - (i, j)从上面走下来f[i-1, j] + w[i, j]
    - (i, j)从左边走过来 f[i, j-1] + w[i, j]
    - f[i, j] = f[i - 1, j]

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N][N];
int t, n, m;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> t;
    while (t--){
        cin >> n >> m;
    
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                cin >> a[i][j];
            }
        }

        // 下标从1开始可以避免特殊判断，如最上面的一条边只能从左边过来，最做左边的一条边只能从上面走下来
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                a[i][j] += max(a[i - 1][j], a[i][j - 1]);
            }
        }
        
        cout << a[n][m] << endl;
    }
    
    return 0;
}
```

### 例题3：最低通行费

一个商人穿过一个 N×N 的正方形的网格，去参加一个非常重要的商务活动。他要从网格的左上角进，右下角出。每穿越中间 1 个小方格，都要花费 1 个单位时间。商人必须在 **(2N−1)** 个单位时间穿越出去。而在经过中间的每个小方格时，都需要缴纳一定的费用。这个商人期望在规定时间内用最少费用穿越出去。请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

**输入格式**

第一行是一个整数，表示正方形的宽度 N。

后面 N 行，每行 N 个不大于 100 的正整数，为网格上每个小方格的费用。

**输出格式**

输出一个整数，表示至少需要的费用。

**数据范围**

1≤N≤100

**输入样例**：

```
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

**输出样例**：

```
109
```

**样例解释**

样例中，最小值为 109=1+2+5+7+9+12+19+21+33109=1+2+5+7+9+12+19+21+33。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N][N];
int n;

int main(){
    
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n;
    
    memset(a, 0x3f, sizeof a);
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++){
            cin >> a[i][j];
            if (i == 1 && j == 1) continue;
            a[i][j] += min(a[i -1][j], a[i][j - 1]);
        }
    }
    
    cout << a[n][n] << endl;
    
    return 0;
}
```

### 例题4：方格取数

设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![2.gif](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

**输入格式**

第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“0 0 0”表示结束。

**输出格式**

输出一个整数，表示两条路径上取得的最大的和。

**数据范围**

N≤10

**输入样例**：

```
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

**输出样例**：

```
67
```

简要思路：

我们设某人同时走两条路，那么设置f[i_1, j_1, i_2, j_2]表示两条路分别从（1, 1）(1, 1)走到(i_1,  j_1)(i_2, j_2)的路径的最大的点。

此时需要考虑走两条路时"同一个格子不能被重复选择"

我们直到只有当i_1 + j_1 = i_2 + j_2时，两条路径的格子才有可能重合

f[k, i_1, i_2]表示所有从(1, 1)(1, 1)分别走到(i_1, k - i_1)(i_2, k - i_2)的路径的最大值，其中k表示两条路线当前走到格子的横纵坐标之和

f[k, i_1, i_2]可由四种状态转移而来：第一条从下方来，第二条从下方来；第一条从下方来，第二条从右方来；第一条从右方来，第二条从下方来；第一条从右方来，第二条从右方来

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 15;
int n;
int w[N][N];
int f[N * 2][N][N];

int main(){
    
    cin >> n;
    int a, b, c;
    while (cin >> a >> b >> c, a || b || c) w[a][b] = c;
    
    for (int k = 2; k <= n + n; k++){
        for (int i1 = 1; i1 <= n; i1++){
            for (int i2 = 1; i2 <= n; i2++){
                int j1 = k - i1, j2 = k - i2;
                if (1 <= j1 && j1 <= n && 1 <= j2 && j2 <= n){
                    int t = w[i1][j1];
                    if (i1 != i2) t += w[i2][j2];
                    int &x = f[k][i1][i2];
                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);	// 两条路都从上方来
                    x = max(x, f[k - 1][i1 - 1][i2] + t);		// i1这条路从上方来， i2这条路从左边来
                    x = max(x, f[k - 1][i1][i2 - 1] + t);		// i1这条路从左边来， i2这条路从上方来
                    x = max(x, f[k - 1][i1][i2] + t);			// i1和i2都从左边来
                }
            }
        }
    }
    
    cout << f[n + n][n][n] << endl;

    return 0;
}
```



## 最长上升子序列模型

### 例题：最长上升子序列

给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

**输入格式**

第一行包含整数 N。

第二行包含 N 个整数，表示完整序列。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

1≤N≤1000，
−10^9≤数列中的数≤10^9

**输入样例**：

```
7
3 1 2 1 8 5 6
```

**输出样例**：

```
4
```

思路简述：

动态规划：

- 状态表示f[i]
  - 集合：所有以第i个数结尾的上升子序列
  - 属性：max
- 状态计算：f[i] = max(f[j]) + 1, j = 1...i - 1

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N], f[N];
int n;

int main(){
    cin >> n;
    for (int i = 0; i < n; i++){
        cin >> a[i];
        f[i] = 1;
        for (int j = 0; j < i; j++){
            if (a[i] > a[j] && f[i] < f[j] + 1) f[i] = f[j] + 1; 
        }
        
    }
    // for_each(f, f + n, [](int x){cout << x << " ";}), cout << endl;
    cout << *max_element(f, f + n) << endl;
    
    
    return 0;
}
```

### 例题：最长上升子序列II

如果数据范围改为 1≤N≤100000，朴素版动态规划做法会超时。

采用贪心策略，若我们找出长度为len的上升子序列的最小元素a，那么长度为len + 1的上升子序列结尾最小的元素b一定满足  a < b。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int n;


int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    vector<int> stk;
    
    for (int i = 0; i < n; i++){
        
        cin >> a[i];
        if (!i){
            stk.push_back(a[i]);
        }else {
            if (a[i] > stk.back()) stk.push_back(a[i]);
            else *lower_bound(stk.begin(), stk.end(), a[i]) = a[i];
        }
    }
    
    cout << stk.size() << endl;
   
    
    return 0;
}
```



### 例题：最长公共子序列

给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。

**输入格式**

第一行包含两个整数 N 和 M。

第二行包含一个长度为 N 的字符串，表示字符串 A。

第三行包含一个长度为 M 的字符串，表示字符串 B。

字符串均由小写字母构成。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

1≤N,M≤1000

**输入样例**：

```
4 5
acbd
abedc
```

**输出样例**：

```
3
```

**思路简要**：

- 动态规划：
  
  - 状态表示f[i, j]：
  
    - 集合：所有在第一个序列的前`i`个字母中出现，且在第二个序列的前`j`个字母中出现的序列
    - 属性：max（最大值）
  
  - 状态计算：
  
    是否选择第一个序列中的第i个字母以及是否选择第二个序列中的第j个字母，可以将状态划分为四种情况：（0， 0）（0， 1）（1，0）（1，1）
  
    状态的转移可以表示为四种情况的最大值：
  
    ```c++
    f[i, j] = max(f[i-1, j-1] + f[i - 1, j] + f[i, j - 1], f[i , j] + 1)
    ```
    
    其中f[i - 1, j]和f[i, j - 1]是包含f[i - 1, j - 1]的，因此只有后面的三种情况
  
    ```c++
    f[i, j] = max(f[i - 1, j] + f[i, j - 1], f[i , j] + 1)
    ```
    
    

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N][N];
char a[N], b[N];
int n, m;
int main(){
    
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i];
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```

### 例题：最短编辑距离

给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

1. 删除–将字符串 A 中的某个字符删除。
2. 插入–在字符串 A 的某个位置插入某个字符。
3. 替换–将字符串 A 中的某个字符替换为另一个字符。

现在请你求出，将 A 变为 B 至少需要进行多少次操作。

**输入格式**

第一行包含整数 n，表示字符串 A 的长度。

第二行包含一个长度为 n 的字符串 A。

第三行包含整数 m，表示字符串 B 的长度。

第四行包含一个长度为 m 的字符串 B。

字符串中均只包含大小写字母。

**输出格式**

输出一个整数，表示最少操作次数。

**数据范围**

1≤n,m≤1000

**输入样例**：

```
10 
AGTCTGACGC
11 
AGTAAGTAGGC
```

**输出样例**：

```
4
```

简要思路：

- 简要思路
  - 状态表示f[i, j]
    - 集合：将所有a[1...i]变成b[1...j]的操作方式
    - 属性： min
  - 状态计算
    - f[i, j]是由上一次操作之后，再通过删、增、改三种方式得到的，那么可通过查找上一次操作的最小次数，然后取三者最小的次数。
      - 若f[i, j]是由删除操作得到：f[i, j] = f[i - 1, j] + 1,（将a[1...i-1]变成b[1...j]的最小操作次数 加上这次的删除操作 1 次）
      - 若f[i, j]是由增添操作得到：f[i, j] = f[i, j - 1] + 1,（将a[1...i]变成b[1...j - 1]的最小操作次数加上这次的增添操作1 次）
      - 若f[i, j]是由替换操作得到：f[i, j] = f[i - 1, j -1] + 1 || 0,（将a[1...i-1]变成b[1...j-1]的最小次数加上这次的替换操作， 如果a[i]和b[j]相等则加0次，不等则需要替换，加1 次）

代码：

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main(){
        
    scanf("%d%s", &n, a + 1);
    scanf("%d%s", &m, b + 1);
    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;

    for (int i = 1; i <= n; i++) f[i][0] = i;
    for (int i = 1; i <= m; i++) f[0][i] = i;
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            f[i][j] = min({f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1] + (a[i] != b[j])});
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```
