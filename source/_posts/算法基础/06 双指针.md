---
title: 06 双指针
date: 2022-05-27 21:39:13
tags: 算法基础
---



# 双指针

一般循环中两个指针的时间复杂度是O(n^2),但是使用了双指针可以使时间复杂度降为O(n)，其中主要就是利用了两个指针的交替相指，避免重复的无意义的循环遍历。

暴力i的同时查看i与j的单调关系。

一般双指针的代码的模板如下：

```c++
for (int i = 0, j = 一个值; i < n; i++){
    
    while(j < n && check(j)){
        
    }
    //check(j) 是指j满足某种性质
    // 具体的问题
}
```

常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作

#### 例题：

给定一个长度为 n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

#### 输入格式

第一行包含整数 n。

第二行包含 n 个整数（均在 0∼10^5 范围内），表示整数序列。

#### 输出格式

共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

#### 数据范围

1≤n≤10^5

#### 输入样例：

```
5
1 2 2 3 5
```

#### 输出样例：

```
3
```

```c++
#include <iostream>
using namespace std;
const int N = 10010;
int a[N], s[N];	//这里的s[i]记录a[i]中的数字出现的数量，哈希表一样的功能，这样可在O（1）的时间复杂度找到当前的数字是否出现过
int n;
int main(){
    cin >> n;
    
    for(int i = 0; i < n; i++) cin >> a[i];
    
    int res = 0;
    
    for(int i = 0, j = 0; i < n; i++){
        s[a[i]]++;
        // 如果s[a[i]] > 1说明这个数字出现了不止一次
        while (s[a[i]] > 1){	// 找到了重复的位置，后续将j移动到i的位置
            s[a[j]]--;
            j++;	// j作为不重复数组的右边界往后移动
        }
        
        res = max(res, i-j+1);
    }
    
    cout << res << endl;
}
```

最终的时间复杂度是严格小于2n的。

