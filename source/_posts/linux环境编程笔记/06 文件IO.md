---
title: 06 文件IO
date: 2022-05-27 21:02:46
tags: linux环境编程
---

# 文件IO

[TOC]



我们一般常说的IO一般以内存的角度考虑输入输出，即从文件中读取数据**输入**到内存中，内存中的数据读出来**输出**到文件中的。

两种实现跨平台的方式：

1、类似java虚拟机，不同平台的虚拟机不同

2、相同的第三方库，操作时调用不同操作系统的系统API

![文件IO](/images/image/文件IO.png)

标准C库IO和linux系统IO的联系和区别：

标准C库IO是带有缓冲区的，读写文件时是先和缓冲区进行交互，之后再调用缓冲区进行缓冲区与磁盘的进行文件读写操作。

![标准C库和系统API的联系](/images/image/标准C库和系统API的联系.png)

### 虚拟地址空间

![虚拟地址空间](/images/image/虚拟地址空间.png)

虚拟地址空间是人们虚拟出来为解决一些程序运行问题的地址空间。以32位机器为例，虚拟地址空间的大小为4G，其中0到3G是我们可操作的，这段地址空间称为用户区，包含程序运行的相关信息，3G到4G被称为内核区，是我们不能直接使用的地址空间，其中包含linux内核相关的操作信息，只能通过系统调用的方式来使用。

### 文件描述符

![文件描述符](/images/image/文件描述符.png)

文件描述符是在程序运行期间进程用到的文件的一种描述。文件描述符存在于虚拟地址空间内核空间PCB的文件描述表中，PCB为进程控制块，是对进程进行管理的文件，进程运行中每打开一个文件，就占用文件描述符。默认PCB文件描述符表的大小为1024，其中前三个是对应当前使用终端的文件描述符，这三个文件描述符默认是打开状态，对应终端操作的三个文件，分别是标准输入、标准输出以及标准错误。



### open函数

```c
/*
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    int open(const char *pathname, int flags);
    作用：打开一个文件
    参数：
        - pathname: 文件路径及文件名
        - flags: 对文件的操作设置以及一些其他的设置
            O_RDONLY,O_WRONLY, or O_RDWR    这三个设置是互斥的
    
    返回值:
        若调用成功返回非负的文件描述符
        调用失败会返回-1，这种情况下会设置errno的值来描述该错误
    
    errno: 属于linux系统函数库，是一个全局变量，记录的是错误号
            可使用perror函数打印错误信息
    
    
    #include <stdio.h>

    void perror(const char *s);
    作用：打印errno对应的错误信息
    参数：
        -s 用户自定义描述，例如 "hello" 最终输出的是 "hello:xxx(实际的错误描述)"
    

    int open(const char *pathname, int flags, mode_t mode);
        作用：创建一个新文件
        参数：
            - pathname: 创建的文件名
            - flags: 对文件操作权限以及其他设置
                必选项：O_RDONLY, O_WRONLY, or O_RDWR 这三个是互斥的
                可选项：O_CREAT 文件不存在会创建新文件
            - mode: 必须是一个八进制的数，表示用户对创建文件的操作权限，最终的权限是 mode & ~umask, 					umask室为了抹去某些权限


    #include <unistd.h>

    int close(int fd);
    作用：关闭一个文件描述符
*/



#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
int main(){
    
    int fd = open("a.txt", O_RDONLY);	// 打开文件，只读

    if (fd == -1){
        perror("hello");	// 输出错误信息
    }
    
    close(fd);	// 关闭文件

    return 0;
}
```

![](/images/image/open函数.png)



### read、write函数

读和写都是从内存的角度去诠释的，读是将文件中的内容读到内存中，写是将内存中的数据写到文件中，借助读和写的功能可完成文件的拷贝功能。

```c
/*
    #include <unistd.h>
    ssize_t read(int fd, void *buf, size_t count);
        参数：
            - fd： 读取文件的文件描述符，通过open得到的，通过文件描述符操作某一个文件
            - buf： 读取数据存放的地方，数组的地址，是一个传出参数，将读取的数据通过该数组传到内存中
            - count: 指定的数组的大小
        返回值：
            - 成功： 
                >0: 返回读取到的字节数
                =0：文件已经读完了
            - 失败：-1 ，并设置errno
        
    #include <unistd.h>
    ssize_t write(int fd, const void *buf, size_t count)
        参数：
            - fd: 文件描述符，通过open得到
            - buf: 往磁盘写入的数据，一般是数组
            - count: 要写的数据的实际的大小
        返回值：
            - 成功：写入的实际的字节数
            - 失败：返回-1， 并重新设置errno
*/
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(){

    // 1、通过open打开english.txt文件
    int srcfd = open("english.txt", O_RDONLY);
    if(srcfd == -1){
        perror("open");
    }
    // 2、创建一个新的文件（拷贝文件）
    int desfd = open("cpy.txt", O_WRONLY | O_CREAT, 0777);
    if(desfd == -1){
        perror("open");
    } 
    // 3、频繁的读写文件
    char buf[1024] = {0};
    int len = 0;
   
    while((len = read(srcfd, buf, sizeof(buf))) > 0){
        write(desfd, buf, len);
    }
    // 4、关闭文件
    close(srcfd);
    close(desfd);
    return 0;
}
```

### lseek 函数

```c
/*
    标准C库函数
    #include <stdio.h>
    int fseek(FILE *stream, long offset, int whence);


    linux系统调用函数
    #include <sys/types.h>
    #include <unistd.h>
    
    off_t lseek(int fd, off_t offset, int whence);
        参数：
            - fd: 文件描述符，通过open得到，可通过fd操作某个文件
            - offset: 偏移量
            - whence:
                SEEK_SET: 设置文件指针的偏移量
                SEEK_CUR：从当前位置 + 第二个参数offset的值
                SEEK_END：文件大小 + 第二个参数offset的值
        
        返回值：返回文件指针的位置
        
        作用：
        1、移动文件指针到文件头
        lseek(fd, 0, SEEK_SET)

        2、获取当前文件指针的位置
        lseek(fd, 0, SEEK_CUR)

        3、获取文件长度
        lseek(fd, 0, SEEK_END)

        4、拓展文件的长度，如将10b大小的文件改成110b
        lseek(fd, 100, SEEK_END)    需要写一次数据才能生效

*/

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(){
    
    int fd = open("hello.txt", O_RDWR);
    if (fd == -1){
        perror("open");
    }
	
    
    // 将文件扩大100个字节
    int res = lseek(fd, 100, SEEK_END);
    if (res == -1){
        perror("lseek");
    }

    //写一个空字符
    write(fd, " ", 1);	// 扩大文件的容量需重写一次数据才生效

    // 关闭文件
    close(fd);
    return 0;
}
```

### stat、lstat函数

```c++
/*
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <unistd.h>

    int stat(const char *pathname, struct stat *statbuf);
        作用：获取一个文件相关的一些信息
        参数：
            - pathname: 操作文件的文件名
            - statbuf: 传出参数，保存获取到文件的一些信息
        返回值：
            成功： 0
            失败： -1 ，并且设置errno
        
    int lstat(const char *pathname, struct stat *statbuf);
        作用和stat有一点区别，当获取一个软链接文件的信息时，stat是获取的软连接文件链接的文件，而使用lstat才能获取到软连接文件本身
        参数及返回值与stat()函数相同


    // 保存文件信息的结构体
    // struct stat {
    //            dev_t     st_dev;          	文件的设设备编号 
    //            ino_t     st_ino;          	节点 
    //            mode_t    st_mode;       	 	文件的类型和存取的权限 
    //            nlink_t   st_nlink;        	连到该文件的硬链接数目 
    //            uid_t     st_uid;         	用户组ID 
    //            gid_t     st_gid;          	组ID 
    //            dev_t     st_rdev;         	设备文件的设备编号 
    //            off_t     st_size;         	文件字节数(字节大小) 
    //            blksize_t st_blksize;      	块大小 
    //            blkcnt_t  st_blocks;       	块数 
    //            struct timespec st_atim;   	最后一次访问时间 
    //            struct timespec st_mtim;   	最后一次修改时间 
    //            struct timespec st_ctim;   	最后一次(属性)改变时间 

    //            关于时间的定义
    //            #define st_atime st_atim.tv_sec      
    //            #define st_mtime st_mtim.tv_sec   
    //            #define st_ctime st_ctim.tv_sec
    //    };
*/

#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main(){

    struct stat stat_buf;
    int res = stat("a.txt", &stat_buf);
    if (res == -1){
        perror("stat");
        return -1;
    }

    int size = stat_buf.st_size;

    printf("a.txt size :%d\n", size);
}
```

### 模拟实现 ls -l

```c
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <pwd.h>	// getpwuid()
#include <grp.h>	// getgrgid()
#include <time.h>	// ctime()
#include <string.h> // strnpy()

// 模拟实现 ls -l 功能
//  文件类型和文件权限 硬链接数 所属用户 所属组 占用字节大小 时间 文件名
//  -rw-rw-r-- 1 chalino chalino 146 11月 19 20:29 ls-l.c

int main(int argc, char* argv[]){

    // 判断输入参数的个数是否正确
    if (argc < 2){
        printf("%s filename", argv[0]);
        return -1;
    }

    // 通过stat函数获取文件的信息
    struct stat stat_buf;
    int res = stat(argv[1], &stat_buf);
    if (res == -1){
        perror("stat");
        return -1;
    }

    // 1、获取文件类型
    char permits[11] = {0};
    switch (stat_buf.st_mode & S_IFMT)
    {
    // 符号链接（软链接）
    case S_IFLNK:
        permits[0] = 'l';
        break;
    
    // 块设备
    case S_IFBLK:
    permits[0] = 'b';
        break;
    
    // 字符设备
    case S_IFCHR:
    permits[0] = 'c';
        break;
    
    // 管道
    case S_IFIFO:
    permits[0] = 'p';
        break;
    
    // 普通文件
    case S_IFREG:
    permits[0] = '-';
        break;
    
    // 目录文件
    case S_IFDIR:
    permits[0] = 'd';
        break;
    
    // 套接字文件
    case S_IFSOCK:
    permits[0] = 's';
        break;

    // 未知的文件
    default:
    permits[0] = '?';
        break;
    }


    // 2、判断文件的访问权限

    // 文件所有者权限
    permits[1] =  (stat_buf.st_mode & S_IRUSR)? 'r':'-';    // 读权限
    permits[2] =  (stat_buf.st_mode & S_IWUSR)? 'w':'-';    // 写权限
    permits[3] =  (stat_buf.st_mode & S_IXUSR)? 'x':'-';    // 执行权限

    // 文件所在的组权限
    permits[4] =  (stat_buf.st_mode & S_IRGRP)? 'r':'-';    // 读权限
    permits[5] =  (stat_buf.st_mode & S_IWGRP)? 'w':'-';    // 写权限
    permits[6] =  (stat_buf.st_mode & S_IXGRP)? 'x':'-';    // 执行权限 

    // 其他访问者权限
    permits[7] =  (stat_buf.st_mode & S_IROTH)? 'r':'-';    // 读权限
    permits[8] =  (stat_buf.st_mode & S_IWOTH)? 'w':'-';    // 写权限
    permits[9] =  (stat_buf.st_mode & S_IXOTH)? 'x':'-';    // 执行权限 

    // 3、硬链接数
    int link_num = stat_buf.st_nlink;

    // 4、文件所有者
    // 这里使用getpwuid()函数获取用户名称
    char *file_usr = getpwuid(stat_buf.st_uid)->pw_name;
    
    // 5、文件所在组
    // 使用getgrgid()函数或者用户所在的组
    char *file_grp = getgrgid(stat_buf.st_gid)->gr_name;

    // 6、获取文件大小
    long int file_size = stat_buf.st_size;

    // 7、获取修改的时间
    // 使用ctime函数获取时间
    char * time = ctime(&stat_buf.st_mtim.tv_sec);
    char mtime[512] = {0};
    strncpy(mtime, time, strlen(time) - 1);
    
    // 输出
    char buf[1024] = {0};
    sprintf(buf, "%s %d %s %s %ld %s %s", permits, link_num, file_usr, file_grp, file_size, mtime, argv[1]);

    printf("%s\n", buf);

    return 0;
}
```



### 文件属性相关的函数

```c
// 判断文件的权限或者文件是否存在
int access(const char *pathname, int mode);
// 修改文件权限
int chmod(const char *filename, int mode);
// 修改文件所有者或者所有组
int chown(const char *path, uid_t owner, gid_t group);
// 缩减或者扩展某一个文件的大小
int truncate(const char *path, off_t length);
```

#### `int access(const char *pathname, int mode);`

```c
/*
    #include <unistd.h>
    int access(const char *pathname, int mode);

    作用：
        判断调用该函数的进程对该文件是否有相应的权限
    参数：
        - pathanme: 判断文件的路径
        - mode:  
            R_Ok: 是否有读权限
            W_OK: 是否有写权限
            X_OK: 是否有执行权限
            F_Ok: 判断文件是否存在
    返回值：
        成功：返回 0
        失败：返回 -1

*/

#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]){

    int ret = access("a.txt", F_OK);
    if (ret == -1){
        perror("access");
    }
    else printf("文件存在!!!\n");
    return 0;
}
```



#### `int chmod(const char *filename, int mode);`

```c
/*
       #include <sys/stat.h>
       int chmod(const char *pathname, mode_t mode);
       作用：修改文件的权限
       参数：
              - pathname: 文件路径
              - mode: 需要修改的权限值，是一个八进制的数
       返回值：
              成功：0
              失败：-1 ，设置 errno
       

*/
#include <sys/stat.h>
#include <stdio.h>

int main(int argc, char *argv[]){
       
       int ret = chmod("a.txt", 0775);
       if (ret == -1){
              perror("chmod");
              return -1;
       }
       
       return 0;
}
```



#### `int truncate(const char *path, off_t length);`

```c
/*
    #include <unistd.h>
    #include <sys/types.h>
    int truncate(const char *path, off_t length);
        作用：缩减或拓展文件的尺寸至指定的大小
        参数：
            - path:修要修改文件路径
            - length: 需要文件最终变成的大小,单位是字节
        返回值：
            成功：0
            失败：-1， 并设置errno

*/

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char *argv[]){
    int res = truncate("a.txt", 5);
    if (res == -1){
        perror("truncate");
        return -1;
    }
    return 0;
}
```

### 文件目录操作函数

```c
// 创建一个新文件夹
int mkdir(const char *pathname, mode_t mode);
// 删除一个空文件夹
int rmdir(const char *pathname);
// 给文件夹改名
int rename(const char *oldpath, const char *newpath);

int chdir(const char *path);
char *getcwd(char *buf, size_t size);
```



#### `int rename(const char *oldpath, const char *newpath);`

```c
/*
       #include <stdio.h>

       int rename(const char *oldpath, const char *newpath);
        作用：修改文件名或者移动文件
        参数：
            - oldpath:原路径
            - newpath:新路径
        返回值：
            成功：0
            失败：-1，设置errno
*/
#include <stdio.h>

int main(int argc, char *argv[]){
    if (argc < 3){
        printf("!!!");
    }
    int res = rename(argv[1], argv[2]);
    if (res == -1){
        perror("rename");
        return -1;
    }
    return 0;
}
```

测试结果：

![](/images/image/rename.png)

#### `int chdir(const char *path);`

#### `char *getcwd(char *buf, size_t size);`

```c
/*

        #include <unistd.h>
        int chdir(const char *path);
        作用：切换进程的工作路径
        参数：
            - path ：想要切换的工作路径
        返回值：
            成功： 0
            失败： -1，设置errno

        #include <unistd.h>
        char *getcwd(char *buf, size_t size);
        作用：获取当前进程的工作路径
        参数：
            - buf: 传出参数，保存当前路径的名称
            - size: 传出内存的大小
        返回值：
            buf的地址

*/

#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>

int main(int argc, char *argv[]){
	
    // 获取当前的工作文件夹
    char buf[128];
    getcwd(buf, sizeof(buf));
    printf("工作路径: %s\n", buf);
	
    // 切换到新的工作目录
    int res = chdir("../newdir");
    if (res == -1){
        perror("chdir");
        return -1;
    }
	
    // 在新的工作路径下新建文件夹
    res = open("a.txt", O_CREAT | O_RDWR);
    if (res == -1){
        perror("open");
        return -1;
    }
	
    // 获取新的工作目录
    char buf1[128];
    getcwd(buf1, sizeof(buf1));
    printf("新的工作路径:%s\n", buf1);

    return 0;
}
```

测试结果:

![](/images/image/chdir.png)



![](/images/image/getcwd.png)





### 目录遍历函数

```c
// 打开一个目录
DIR* opendir(const char *name);
// 地区目录中的有关信息
struct dirent *readdir(DIR *dirp);
// 关闭目录
int closedir(DIR *dirp);
```

```c
/*
    #include <sys/types.h>
    #include <dirent.h>

    DIR *opendir(const char *name);
    作用：打开一个目录
    参数：
        - name: 目录的名称
    返回值：
        成功：指向文件流的指针,DIR* 类型
        失败：NULL， 设置errno

    #include <dirent.h>
    struct dirent *readdir(DIR *dirp);
    作用：读取目录中的内容
    参数：
        - dirp 对应目录的目录流
    返回值：
        成功：目录流中目录实体的指针，是struct dirent * 类型，存储从目录流IDR*中读取到的目录信息
        失败：NULL
            读到目录流末尾虽然会返回NULL，但是不会设置errno
            读取目录流失败返回NULL，设置errno


    #include <sys/types.h>
    #include <dirent.h>
    int closedir(DIR *dirp);
    作用：关闭一个目录
    参数：关闭目录的目录流
    返回值：
        成功：0
        失败：-1， 设置errno
    
    
*/

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int getFileNum(const char* path);

int main(int argc, char *argv[]){

    if (argc < 2){
        printf("%s path\n", argv[0]);
        return -1;
    }

    int num = getFileNum(argv[1]);

    printf("普通文件的个数为%d个\n", num);


    return 0;
}


int getFileNum(const char* path){

    // 定义总的普通文件的个数
    int total = 0;

    // 1、打开目录
    DIR *dir = opendir(path);
    if (dir == NULL){
        perror("opendir");
        exit(0);
    }

    // 2、读取目录
    struct dirent *ptr = NULL;
    while((ptr = readdir(dir)) != NULL){
        // 获取名称
        char *dname = ptr->d_name;

        // 忽略. 和 .. 目录
        if (strcmp(dname, ".") == 0 || strcmp(dname, "..") == 0){
            continue;
        }

        // 判断是普通文件还是目录
        if(ptr->d_type == DT_DIR){
            char newpath[256];
            sprintf(newpath, "%s/%s", path, dname);
            total += getFileNum(newpath);
        }
        else if (ptr->d_type == DT_REG){
            total++;
        }
    }

    return total;
}
```

### 和文件描述符相关的函数

```c
// 复制文件描述符
int dup(int oldfd);
// 重定向文件描述符
int dup2(int oldfd, int newfd);
```



#### `int dup(int oldfd);`

```c
/*

    #include <unistd.h>
    int dup(int oldfd);
    作用：复制一个文件，并返回新文件的文件描述符
    参数：旧文件的文件描述符
    返回值：新文件的的文件描述符，新文件的文件描述符是进程的PCB中空闲的最小编号。

*/

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

int main(int argc, char *argv[]){
    int fd = open("a.txt", O_CREAT | O_RDWR, 0664);
    if (fd == -1){
        perror("open");
        return -1;
    }

    int fd1 = dup(fd);
    if (fd1 == -1){
        perror("dup");
        return -1;
    }

    printf("%d, %d", fd, fd1);

    close(fd);

    const char *str = "hello, world";
    
    int ret = write(fd1,str, strlen(str));
    if (ret == -1){
        perror("write");
        return -1;
    }

    close(fd1);

    return 0;
}
```

#### `int dup2(int oldfd, int newfd);`

```c
/*
    #include <unistd.h>
    int dup2(int oldfd, int newfd);
    作用：重定向文件描述符
        oldfd指向 a.txt, newfd指向b.txt
        如果函数调用成功，newfd和b.txt做close, 然后newfd指向a.txt
    返回值：成功返回文件描述符， 失败返回-1
*/

#include <sys/types.h>
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]){

    // fd 打开a.txt
    int fd = open("a.txt", O_CREAT | O_RDWR, 0664);
    if (fd == -1){
        perror("open");
        return -1;
    }

    // fd1 打开b.txt
    int fd1 = open("b.txt", O_CREAT | O_RDWR, 0664);
    if (fd1 == -1){
        perror("open");
        return -1;
    }

    // 打印两个文件的文件描述符
    printf("fd %d, fd1 %d\n", fd, fd1);

    // 文件描述符的重定向
    int fd2 = dup2(fd, fd1);

    // 用新的文件描述符来修改文件
    const char *str = "hello, world";
    int ret = write(fd1, str, strlen(str));
    if (ret == -1){
        perror("write");
        return -1;
    }
    

    // 再次打印新的文件描述符
    printf("fd %d, fd1 %d, fd2 %d\n", fd, fd1, fd2);
    close(fd);
    close(fd1);
}
```

测试结果

![](/images/image/dup2.png)



#### `fcntl(int fd, int mod, ...)`

```c++

/*

#include <unistd.h>
#include <fcntl.h>

int fcntl(int fd, int cmd, ...)
    参数：
        fd:文件描述符
        cmd:对文件描述符进行何种操作的指令
            - F_DUPFD: 复制一个文件描述符，复制的对象是第一个参数fd，得到一个新的文件描述符（返回值）
                int ret = fcntl(fd, F_DUPFD);

            - F_GETFL: 获取指定文件描述符的文件状态flags
                flag: 如O_RDONLY、O_WRONLY、O_RDWR等，和通过open函数需要的flags是一个东西
            
            - F_SETFL: 设置文件描述符的flags
                必选项: O_RDONLY, O_WRONLY, O_RDWR 不可以被修改
                可选项: O_APPEND, and O_NONBLOCK 可以被修改
                    O_APPEND 表示追加数据
                    O_NONBLOCK 设置成非阻塞
        
                    阻塞和非阻塞: 描述的是函数调用的行为，调用过程中是否被打断

*/

#include <unistd.h>
#include <fcntl.h>

// perror()
#include <stdio.h>

// open函数
#include <sys/types.h>
#include <sys/stat.h>
// #include <fcntl.h>

int main(int argc, char *argv[]){

    // 创建一个文件
    int fd = open("a.txt", O_WRONLY | O_CREAT, 0664);
    if (fd == -1){
        perror("open");
    }
	// 打印文件描述符
    printf("%d\n", fd);
	
    // 复制文件描述符
    int ret = fcntl(fd, F_DUPFD);
    
    // 打印新的文件描述符
    printf("%d\n", ret);

    return 0;
}
```

![](/images/image/fcntl_O_DUPFD.png)

```c++
#include <unistd.h>
#include <fcntl.h>

// perror()
#include <stdio.h>

// open函数
#include <sys/types.h>
#include <sys/stat.h>
// #include <fcntl.h>

#include <string.h>

int main(int argc, char *argv[]){

    // 修改或者获取文件状态flags
    int fd = open("a.txt", O_RDWR);   // 此时只能读文件
    if (fd == -1){
        perror("open");
        return -1;
    }
    // 更改文件描述符的状态，给falgs加入 O_APPEND这个标记，确保可以给该文件写数据

    // 1、先获取文件描述符的状态flags
    int flag = fcntl(fd, F_GETFL);

    // 2、更改文件描述符的状态，给falgs加入 O_APPEND这个标记，确保可以给该文件写数据
    int ret = fcntl(fd, F_SETFL, flag | O_APPEND);

    // 向文件中写数据
    char * str = "nihao";
    write(fd, str, strlen(str));
    close(fd);
    return 0;
}
```

![](/images/image/fcntl_O_APPEND.png)

