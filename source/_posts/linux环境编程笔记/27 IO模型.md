---
title: 27 UNIX五大IO模型
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 1、阻塞 blocking

调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。

![](/images/image/阻塞.png)

# 2、非阻塞 non-blocking（`NIO`）

非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调 用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 `errno` 区分这两 种情况，对于`accept`，`recv` 和  `send` ，事件未发生时，`errno` 通常被设置成 `EAGAIN`。

![](/images/image/非阻塞.png)

# 3、IO复用（IO multiplexing）

`Linux` 用 `select`/`poll`/`epoll` 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是 这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数

![](/images/image/IO多路复用.png)

# 4、信号驱动

Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到`SIGIO` 信号，然后处理 IO 事件。

![](/images/image/信号驱动.png)

内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统`API`的调用次数，提高了效率。

# 5、异步

Linux中，可以调用 `aio_read` 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

![](/images/image/异步.png)

