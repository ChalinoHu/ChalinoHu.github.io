---
title: 03 静态库和动态库
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 静态库和动态库



### 一、静态库和动态库的区别

编写库的程序和一般的程序的区别不大，只是库不能单独运行。

静态库和动态库的区别是：静态库在程序的**链接阶段被复制到了程序中**，动态库在连接阶段没有复制到程序中，而是在**程序运行时由系统动态加载到内存中供程序调用**。

库的好处：具有保密性，便于分发和部署

### 二、静态库的制作与使用

##### 1、命名规则

`linux`平台中一般命名为`libxxx.a`，其中**前缀lib**和**后缀.a**是**固定**的，中间静态库名xxx可自取。

##### 2、静态库的制作

(1)、首先使用`gcc -c `获得.o文件 	

(2)、使用`ar`工具(archive)来进行打包

```shell
ar rcs libxxx.a test1.o test2.o
# r 将文件插入备存文件中
# c 建立备存文件
# s 索引
```

##### 3、静态库的使用

![](/images/image/image-20211030223714029.png)

如果我们的文件目录如上图所示：

首先将`/src` 目录下的.c文件制作成动态连接库

```shell
cd src	#切换到src目录

gcc -c *.c -I ../include/	#编译与汇编成目标代码。得到之后的.o文件
```

![](/images/image/image-20211030224854701.png)

其中 `-I`是指定头文件的目录上一级的子目录include中。

```
ar rcs libcalc.lib *.o
```

![](/images/image/image-20211030225027192.png)

此时文件中出现了我们制作的静态库文件`libcalc.lib`，静态库的库名为`calc`

之后返回`main.c`文件所在的目录

```shell
cd ..
```

此时的文件树为：

![](/images/image/image-20211030225831239.png)

此时来链接静态库文件

```shell
gcc main.c -o main -I ./include/ -L src/ -l calc	
# 注意-l 后面接的是静态库名而不是静态库文件名
```

### 三、动态库的制作和使用

动态库文件命名规则： `libxxx.so`，和静态库一样，前缀lib和后缀.so是固定的，中间`xxx`为自定义的动态库的名称。

制作过程：

```shell
# gcc得到.o文件，得到和位置无关的代码，pic和PIC在x86机构下暂时没什么区别
gcc -c -fpic/-fPIC a.c b.c
```

```shell
# 得到动态库
gcc -shared a.o b.o -o libcalc.so
```

当我们像加载静态库那样准备与我们的测试文件`main.cpp`链接后再执行编译好的文件，系统报错：

![](/images/image/image-20211106205025977.png)



此时我们需要了解静态库和动态库的工作原理：

我们在使用`GCC`将静态库进行链接时，`GCC`会将静态库中的**代码**打包到**可执行文件**中。

而动态库代码不会被打包到可执行文件中，而是把动态库的一些可执行信息放到可执行文件中。而是被加载到**内存**中。

我们可通过`ldd`（list dynamic dependencies）命令来检查动态库的依赖关系

```shell
ldd main	# main 是我们编译好的测试文件
```

![](/images/image/image-20211106212219863.png)

上图可以看到系统没有找我我们的动态库`libcalc.so`的内存地址，因此无法定位到我们的动态库文件。

动态库加载的时间：当可执行文件中需要用到**动态库提供的API**时，动态库将会被加载到内存中使用。

​	系统加载可执行代码时，能够知道加载的动态库的名称，但不知道动态库的绝对路径，此时需要系统的**动态载入器**（上图中的`lib64/ld-linux-x86-64.so.2`）来获取动态库的绝对路径。

​	对于elf格式的可执行程序，是`ld-linux.so`来完成的，获取绝对路径需要先后获取elf文件的`DT-RPATH段`（虚拟地址空间，我们无法作出修改）——>环境变量`LD_LIBRARY_PATH`——>`/etc/ld.so.cache`文件列表——>`/lib/`——>`/usr/lib`目录找到库文件后将其载入内存中。



#### 解决动态载入器的动态库加载失败问题，让系统知道动态库的绝对路径地址

#### 1、配置`LD_LIBRARY_PATH`环境变量

```shell
pwd
# /home/chalino/linux/lesson_static_lib/library/lib
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/chalino/linux/lesson_static_lib/library/lib
echo $LD_LIBRARY_PATH
#:/home/chalino/linux/lesson_static_lib/library/lib
```

![](/images/image/image-20211106222928244.png)

如上图所示，再次使用ldd来查看动态库calc的地址就能看到环境变量下的地址了

运行测试文件main,就可以正常运行程序了。

![](/images/image/image-20211106223300478.png)

上述配置方式是在终端中进行配置的，当我们关闭该终端后配置的环境变量就失效了，因此当我们打开新的终端运行测试文件main时会出现错误信息:

![](/images/image/image-20211106223910155.png)

而且当我们打印`LD_LIBRARY_PATH`时也看不到我们之前配置的环境变量。

##### 两种永久配置环境变量的方式

###### (1)、用户级别配置环境变量的方式

进入用户目录下修改`.bashrc`文件，该文件是隐藏文件。

```shell
cd ~
vim .bashrc
```

在最后一行插入之前我们在普通终端配置环境变量的指令

```shell
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/chalino/linux/lesson_static_lib/library/lib
```

之后使用source命令或者.命令使文件的修改生效

```shell
. .bashrc
#或者
source .bashrc
```

![](/images/image/image-20211106225952082.png)

再次运行程序，可成功运行。

###### (2)、系统级别下配置环境变量

```shell
sudo vim /etc/profile
```

然后和我们配置用户环境变量一样，在该文件的最后一行加上配置环境变量的命令

```shell
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/chalino/linux/lesson_static_lib/library/lib
```

#### 2、配置`/etc/ld.so.cache`文件列表

`/etc/ld.so.cache`文件不能直接更改，需要间接配置`/etc/ld.so.conf`文件

```shell
sudo vim /etc/ld.so.conf
```

然后在文件中将我们动态库所在的路径写进去

```shell
/home/chalino/linux/lesson_static_lib/library/lib
```

然后更新我们的指令

```shell
sudo ldconfig
```

#### 3、将动态库文件放到`/lib/`或者`/usr/lib`目录下

一般不建议这样做，因为这两个目录下放了很多的动态库文件，可能我们自己的动态库文件放进去后与其他动态库文件重名而使其失效，最终使部分程序无法执行。



### 四、动态库与静态库的优缺点

#### 1、静态库的优缺点：

优点：静态库被打包到应用程序中，加载速度快；发布程序无需提供静态库，移植方便

缺点：消耗系统资源，浪费内存；更新，部署、发布麻烦

![](/images/image/image-20211107155709914.png)

如上图：一段程序中需要用到多次用到相同的库文件，静态库会被打包到程序中多次。

#### 2、动态库的优缺点：

优点：可以实现进程间的资源共享（共享库）；更新、部署的、发布简单；可以控制何时加载到内存中

缺点：加载速度比静态库慢；发布程序需要提供依赖的动态库



