---
title: 22 IO多路复用
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# I/O多路复用

I/O多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能。`linux`下实现I/O多路复用的系统调用主要有`select`、`poll`、`epoll`。

​	IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。	

## 替代IO多路复用的方法：

### 1、同步阻塞IO(BIO)

​	**单线程**场景下，accept一个请求后如果在read和write处阻塞时，将<u>无法处理下一个请求，因此无法处理并发</u>；**多线程**场景下，accept一个请求后，开启一个线程进行read和write，可完成并发操作，但随着请求数增加需要增加线程来进行下一步操作（如read/write/业务），<u>大量的线程需要大量的内存空间等资源，每次accept都开一个线程是一种资源浪费，同时线程切换也是一个巨大的开销。</u>

### 2、同步非阻塞IO(NIO)

服务端每次accept一个请求后，会将当前的fd放到文件描述符集合fds，每次轮询fds中的fd进行非阻塞操作(recv/send)。<u>每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu</u>。

## select

> 主旨思想：
>
> ​	1、首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中
>
> ​	2、调配用一个系统函数select()，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行IO操作时，该函数才返回
>
> ​		a.  `select()`是阻塞的
>
> ​		b.  `select()`对文件描述符的检测的操作是由内核完成的
>
> ​	3、返回时，`select()`会告诉进程有多少（哪些）描述符要及进行IO操作

```c++
/*
    #include <sys/time.h>
    #include <sys/types.h>
    #include <unistd.h>

    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
        - 参数:
            - nfds: 委托内核检测的最大文件描述符的编号 + 1
            - readfds: 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符
                - 一般检测读操作
                - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的是读缓冲区
                - 是一个传入传出参数
            - writefds: 要检测的文件描述符的写的集合，委托内核检测的是文件描述符的写的属性
                - 委托内核缓冲区是不是还可以写数据（缓冲区不满就可以写）
            - exceptsfds: 检测发生异常的文件描述符的集合
            - timeout: 设置的超时时间
                    struct timeval {
                        long    tv_sec;         
                        long    tv_usec;       
                    }
                    - NULL: 永久阻塞，直到检测到了文件描述符有变化
                    - tv_sec = 0, tv_usec = 0: 表示不阻塞
                    - tv_sec > 0, tv_usec > 0: 表阻塞对应的时间
        - 返回值:
            - -1: 失败
            - n(>0): 检测的集合中有n个文件描述符发生了变化

    
    void FD_CLR(int fd, fd_set *set);   // 将文件描述符集合fd_set中fd对应的标志位设置为0
    
    int  FD_ISSET(int fd, fd_set *set); // 判断fd的标志位是0还是1
    
    void FD_SET(int fd, fd_set *set);   // 将fd对应的标志位置为1

    void FD_ZERO(fd_set *set);          // 将所有文件描述符集合对应位置置为0
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/select.h>
#include <string.h>
#include <arpa/inet.h>

int main(){

    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    if (lfd == -1){
        perror("socket");
        exit(-1);
    }

    // 绑定
    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_port = htons(9999);
    int ret = bind(lfd, (struct sockaddr*) &saddr, sizeof saddr);
    if (ret == -1){
        perror("bind");
        exit(-1);
    }

    // 监听
    ret = listen(lfd, 8);
    if (ret == -1){
        perror("listen");
        exit(-1);
    }

    // 创建一个fd_set的集合，存放的是需要检测的文件描述符
    fd_set rds, tmp;
    FD_ZERO(&rds);
    FD_SET(lfd, &rds);
    int maxfd = lfd;

    while(1){
        tmp = rds;
        int ret = select(maxfd + 1, &tmp, NULL ,NULL, NULL);
        if(ret == -1){
            perror("select");
            exit(-1);
        }else if (ret == 0){
            continue;
        }else if (ret > 0){
            // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变
            if (FD_ISSET(lfd, &tmp)){
                // 说明有新的客户端连接进来了
                struct sockaddr_in cliaddr;
                int len = sizeof cliaddr;
                int cfd = accept(lfd, (struct sockaddr*) &cliaddr, &len);
                if (cfd == -1){
                    perror("accept");
                    exit(-1);
                }

                // 将新的文件描述符加入到集合中
                FD_SET(cfd, &rds);
                // 更新最大文件描述符的编号
                maxfd = maxfd > cfd ? maxfd : cfd;
            }


            // 循环找出要读的文件描述符
            for (int i = lfd + 1; i <= maxfd; i++){
                if (FD_ISSET(i, &tmp)){
                    // 说明此时文件描述符发来了数据
                
                    char buf[1024] = {0};
                    int len = read(i, buf, sizeof buf);
                    if (len == -1){
                        perror("read");
                        exit(-1);
                    }else if (len == 0){
                        // 客户端断开了连接
                        printf("client closed..\n");
                        close(i);
                        FD_CLR(i, &rds);
                    } else if (len > 0){
                        printf("recv buf: %s\n", buf);
                        write(i, buf, strlen(buf) + 1);
                    }
                }	/* end of if */
                
                
            }	/* end of for */
        }	/* end of  else if*/
    } /* end of while */


    close(lfd);
    return 0;
}	/* end of main */
```

select的缺点：

​	1、每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

​	2、每次调用select都要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

​	3、select默认支持的文件描述符的数量太小了，默认是1024

​	4、fds集合不能重用，每次都需要重置

## poll

```c
    #include <poll.h>

    struct pollfd {
        int fd;         // 委托内核检测的文件描述符
        short events;   // 委托内核检测文件描述符的什么事件
        short revents;  // 文件描述符实际发生的事件
    };

    int poll(struct pollfd *fds, nfds_t nfds, int timeout);
        - 参数:
            - fds: 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合
            - nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1
            - timeout: 阻时长
                - 0: 不阻塞
                - -1: 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞
                > 0 : 阻塞时长,单位是毫秒
        - 返回值:
            - -1: 失败
            > 0(n) : 成功, n表示检测集合中有n个文件描述符发生变化
```

<img src="/images/image/poll.png" style="zoom: 67%;" />

```c


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <string.h>
#include <arpa/inet.h>
#include <poll.h>

int main(){

    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    if (lfd == -1){
        perror("socket");
        exit(-1);
    }

    // 绑定
    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_port = htons(9999);
    int ret = bind(lfd, (struct sockaddr*) &saddr, sizeof saddr);
    if (ret == -1){
        perror("bind");
        exit(-1);
    }

    // 监听
    ret = listen(lfd, 8);
    if (ret == -1){
        perror("listen");
        exit(-1);
    }

    // 初始化检测的文件描述符数组
    struct pollfd fds[1024];
    for (int i = 0; i < 1024; i++){
        fds[i].fd = -1;
        fds[i].events = POLLIN;
    }

    // 将监听socket加入文件描述符集合
    fds[0].fd = lfd;
    int nfds = 0;

    while(1){
        
        int ret = poll(fds, nfds + 1, -1);
        if(ret == -1){
            perror("select");
            exit(-1);
        }else if (ret == 0){
            continue;
        }else if (ret > 0){
            // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变
            if (fds[0].revents & POLLIN){
                // 说明有新的客户端连接进来了
                struct sockaddr_in cliaddr;
                int len = sizeof cliaddr;
                int cfd = accept(lfd, (struct sockaddr*) &cliaddr, &len);
                if (cfd == -1){
                    perror("accept");
                    exit(-1);
                }

                // 将新的文件描述符加入到集合中
                for (int i = 1; i < 1024; i++){
                    if (fds[i].fd == -1){
                        fds[i].fd = cfd;
                        // fds[i].events = POLLIN;

                        // 更新最大文件描述符的索引
                        nfds = nfds > cfd ? nfds : cfd;
                        break;
                    }
                }
                
            }


            // 循环找出要读的文件描述符
            for (int i = 1; i <= nfds; i++){
                if (fds[i].revents & POLLIN){
                    // 说明此时文件描述符发来了数据
                
                    char buf[1024] = {0};
                    int len = read(fds[i].fd, buf, sizeof buf);
                    if (len == -1){
                        perror("read");
                        exit(-1);
                    }else if (len == 0){
                        // 客户端断开了连接
                        printf("client closed..\n");
                        close(fds[i].fd);
                        fds[i].fd = -1;
                    } else if (len > 0){
                        printf("recv buf: %s\n", buf);
                        write(fds[i].fd, buf, strlen(buf) + 1);
                    }
                }
            }
        }
    }


    close(lfd);
    return 0;
}
```

## epoll

```c

#include <sys/epoll.h>

int epoll_create(int size);
    - 功能:
        返回一个新的epoll实例，并在内核创建一个数据，该数据中有两个比较重要的子数据，一个是需要检测的文件描述符的信息（用红黑树实现），另一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表实现）
    - 参数: 
        - size : 内核版本在2.6之后就没有意义了，可能之前是哈希的写法留下的。随便给一个数，但必须要大于0
    - 返回值:
        - -1 : 失败
        > 0 : 文件描述符，操作epoll实例的epfd

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    - 功能:
        - 对epoll实例进行管理：添加文件描述符信息，删除，修改
    - 参数：
        - epfd : epoll实例对应的文件描述符
        - op : 对epoll实例进行的操作
            - EPOLL_CTL_ADD: 添加
            - EPOLL_CTL_MOD: 修改
            - EPOLL_CTL_DEL: 删除
        - fd : 检测的文件描述符
        - event : 检测文件描述符的事件

            struct epoll_event{
                uint32_t events;  // epoll事件 EPOLLIN, EPOLLOUT, EPOLLERR, EPOLLET
                epoll_data_t data;  
            };

            typedef union epoll_data {
                void *ptr;
                int fd;
                uint32_t u32;
                uint64_t u64;
            } epoll_data_t;

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    - 参数:
        - epfd : epoll实例对应的文件描述符、
        - events : 传出参数，保存了发生变化的文件描述符的信息
        - maxevents : 第二个参数数组的大小
        - timeout : 阻塞时间
            - 0 : 不阻塞 
            - -1: 阻塞，直到检测到fd数据发生变化
            > 0 : 阻塞时长（毫秒）
    返回值：
        - > 0: 返回发生变化的文件描述符的个数
        - -1 : 失败

```

```c
#include <unistd.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>

int main(){

    // 创建socket
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if (lfd == -1){
        perror("socket");
        exit(-1);
    }

    // 绑定
    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_port = htons(9999);
    int ret = bind(lfd, (struct sockaddr*)&saddr, sizeof saddr); 
    if (ret == -1){
        perror("bind");
        exit(-1);
    }

    // 监听
    ret = listen(lfd, 8);
    if (ret == -1){
        perror("listen");
        exit(-1);
    }

    // 创建一个epoll实例
    int epfd = epoll_create(100);
    if (epfd == -1){
        perror("epoll_creat");
        exit(-1);
    }

    // 将监听的文件描述符相关的检测信息添加到epoll实例中
    struct epoll_event epev;
    epev.events = EPOLLIN;
    epev.data.fd = lfd;
    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &epev);
    if (ret == -1){
        perror("epoll_ctl");
        exit(-1);
    }

    struct epoll_event epves[1024];

    while (1){
		// 阻塞等到读事件发生
        int ret = epoll_wait(epfd, epves, 1024, -1);    // 阻塞
        if (ret == -1){
            perror("epoll_wait");
            exit(-1);
        }

        
        for (int i = 0; i < ret; i++){

            if(epves[i].data.fd == lfd){

                // 说明有客户端连接
                struct sockaddr_in cliaddr;
                int len = sizeof cliaddr;
                int cfd = accept(lfd, (struct sockaddr *) &cliaddr, &len);
                if (cfd == -1){
                    perror("accept");
                    exit(-1);
                }

                // 与客户端建立连接
                // 复用上面的 epoll_event 对象
                epev.data.fd = cfd;
                epev.events = EPOLLIN;

                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &epev);
                if (ret == -1){
                    perror("epoll_ctl");
                    exit(-1);
                }
            }else{
                // 有数据到达,需要通信
                if (epves[i].events & EPOLLOUT){    // 若出现写运算则忽略
                    continue;
                }
                char buf[1024] = "";
                int len = read(epves[i].data.fd, buf, sizeof buf);
                if (len == -1){
                    perror("read");
                    exit(-1);
                }else if (len == 0){
                    printf("client closed..\n");
                    epoll_ctl(epfd, EPOLL_CTL_DEL, epves[i].data.fd, NULL);     // epfd中删除断开连接的socket文件
                    close(epves[i].data.fd);
                }else {
                    printf("recv data: %s\n", buf);
                    write(epves[i].data.fd, buf, strlen(buf) + 1);
                }

            }
        }

    }
    close(lfd);
    close(epfd);
    return 0;
}
```

### epoll 两种工作模式

- LT模式（水平触发）

  举个例子：

  假设委托内核检测读事件 -> 检测fd的读缓冲区

  ​	都缓冲区有数据了 -> epoll检测到了之后会给用户发通知

  ​		a. 用户不读数据，数据一直在缓冲区，epoll会一直通知

  ​		b. 用户只读了一部分数据，epoll会发送通知

  ​		c. 缓冲区的数据读完了，不发送通知

  > LT（level - triggered）是缺省的工作方式，并且同时支持block和no-block socket。这种触发方式下，内核会告诉你一个文件描述符是否就绪，然后你可以对这个就绪的fd进行IO操作。如果你不做任何操作，内核会一直通知你。

- ET模式（边沿触发）

  举个例子:

  ​	委托内核检测读数据 ->检测fd的读缓冲区

  ​		读缓冲区有数据 -> epoll检测到了会给用户通知

  ​			a. 用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了

  ​			b. 用户只读一部分数据, epoll不通知

  ​			c. 缓冲区的数据读完了，不通知

  > ET（edge - triggered）是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再处于就绪状态了。值得注意的是，如果一直不对这个fd做IO操作（从而导致它再次变成未就绪状态），内核不会发送更多的通知（only once）。
  >
  > ET模式在很程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高，epoll工作在ET模式下必须使用非阻塞的接口，以避免由于一个文件句柄的阻塞读写把处理多个文件描述符的任务饿死。

```c
// epll et 模式

#include <unistd.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include <errno.h>

int main(){

    // 创建socket
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if (lfd == -1){
        perror("socket");
        exit(-1);
    }

    // 绑定
    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_port = htons(9999);
    int ret = bind(lfd, (struct sockaddr*)&saddr, sizeof saddr); 
    if (ret == -1){
        perror("bind");
        exit(-1);
    }

    // 监听
    ret = listen(lfd, 8);
    if (ret == -1){
        perror("listen");
        exit(-1);
    }

    // 创建一个epoll实例
    int epfd = epoll_create(100);
    if (epfd == -1){
        perror("epoll_creat");
        exit(-1);
    }

    // 将监听的文件描述符相关的检测信息添加到epoll实例中
    struct epoll_event epev;
    epev.events = EPOLLIN;
    epev.data.fd = lfd;
    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &epev);
    if (ret == -1){
        perror("epoll_ctl");
        exit(-1);
    }

    struct epoll_event epves[1024];

    while (1){

        int ret = epoll_wait(epfd, epves, 1024, -1);    // 阻塞
        if (ret == -1){
            perror("epoll_wait");
            exit(-1);
        }

        
        for (int i = 0; i < ret; i++){

            if(epves[i].data.fd == lfd){

                // 说明有客户端连接
                struct sockaddr_in cliaddr;
                int len = sizeof cliaddr;
                int cfd = accept(lfd, (struct sockaddr *) &cliaddr, &len);
                if (cfd == -1){
                    perror("accept");
                    exit(-1);
                }

                // 设置文件描述符的属性，将该文件描述符设cfd置为非阻塞
                int flag = fcntl(cfd, F_GETFL);
                flag |= O_NONBLOCK;
                fcntl(cfd, flag);


                // 与客户端建立连接
                // 复用上面的 epoll_event 对象
                epev.data.fd = cfd;
                epev.events = EPOLLIN | EPOLLET;		// 这里修改为边沿触发方式

                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &epev);
                if (ret == -1){
                    perror("epoll_ctl");
                    exit(-1);
                }
            }else{
                // 有数据到达,需要通信
                if (epves[i].events & EPOLLOUT){    // 若出现写运算则忽略
                    continue;
                }


                // char buf[5] = "";
                // int len = read(epves[i].data.fd, buf, sizeof buf);
                // if (len == -1){
                //     perror("read");
                //     exit(-1);
                // }else if (len == 0){
                //     printf("client closed..\n");
                //     epoll_ctl(epfd, EPOLL_CTL_DEL, epves[i].data.fd, NULL);     // epfd中删除断开连接的socket文件
                //     close(epves[i].data.fd);
                // }else {
                //     printf("recv data: %s\n", buf);
                //     write(epves[i].data.fd, buf, strlen(buf) + 1);
                // }


                // 循环读取所有数据
                char buf[5];
                int len = 0;
                while ((len = read(epves[i].data.fd, buf, sizeof buf)) > 0){
                    // 打印数据
                    printf("recv data : %s\n", buf);
                    write(epves[i].data.fd, buf, len);
                }

                if (len == 0){
                    printf("client closed..\n");
                    
                }else if (len == -1){
                    if (errno == EAGAIN){   // socket文件描述符在非阻塞情况下读数据读完之后也会返回-1
                        printf("data read over...\n");
                    }else {
                        perror("read");
                        exit(-1);
                    }
                    
                }

            }
        }

    }
    close(lfd);
    close(epfd);
    return 0;
}
```

