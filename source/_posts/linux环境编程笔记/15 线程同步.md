---
title: 15 线程同步
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 线程同步

线程的优势在于能够通过全局变量来共享信息，不过这种便捷的共享方式是有代价的，不会确保多个线程不会同时修改同一变量，或者某个线程不会其他线程正在修改的变量。

**临界区**是指访问<u>某一资源共享的代码片段</u>，并且这段代码的操作为**原子操作**，也就是同时访问同一共享资源的其他线程**不应中断**该片段的执行。

**线程同步**：当一个线程在对**内存**进行操作时，其他线程都**不可以**对这个内存地址进行操作且处于**等待状态**，直到该线程完成操作，其他线程才能对该内存地址进行操作。

# 互斥量

- 为避免线程更新共享变量出现问题，可以使用**互斥量(mutex)**来确保<u>同时仅有一个线程可以访问某项资源</u>。可以使用互斥量来保证对任意共享资源的**原子访问**。
- 互斥量有两种状态：**已锁定**（locked）和**未锁定**（unlocked）。任何时候，<u>至多只有一个线程可以锁定该互斥量</u>。<u>试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败</u>，具体取决于加锁时使用的方法。
- 一旦线程锁定该线程量，随即成为该互斥量的所有者，<u>只有所有者才能给互斥量解锁</u>。一般情况下，对某一共享资源（可能有多个变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议：
  1. 针对共享资源锁定互斥量
  2. 访问共享资源
  3. 对互斥量解锁

## 互斥量操作相关的函数

```c++

/*
    #include <pthread.h>

    int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
        - 功能：初始化一个互斥量
        - 参数：
            - mutex：需要初始化的互斥量变量
            - attr：互斥量相关的属性，一般传递NULL
        - restrict : C语言的修饰符，被他修饰的指针，不能被另一个指针操作。  
            
    int pthread_mutex_lock(pthread_mutex_t *mutex);
        - 加锁，阻塞的，如果有一个线程加锁了，那么其他线程只能阻塞等待。
    int pthread_mutex_trylock(pthread_mutex_t *mutex);
        - 尝试加锁，如果加锁失败，不会阻塞，直接返回。
    int pthread_mutex_unlock(pthread_mutex_t *mutex);
        - 解锁
    int pthread_mutex_destroy(pthread_mutex_t *mutex);
        - 释放互斥量的资源
*/

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

// 静态全变量区
int tickets = 200;

// 创建一个互斥量
pthread_mutex_t mutex;

void * selltickes(void * arg){
    // 卖票
    while(1){
        // 加锁
        pthread_mutex_lock(&mutex);
        if (tickets){
            usleep(8000);
            printf("%ld正在卖第%d张票!\n", pthread_self(), tickets);
            tickets--;
        }else {
            pthread_mutex_unlock(&mutex);
            break;
        }   
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

int main(int argc, char* argv[]){

    pthread_mutex_t mutex;
    pthread_mutex_init(&mutex, NULL);
    // 创建3个子线程
    pthread_t tid1, tid2, tid3;
    pthread_create(&tid1, NULL, selltickes, NULL);
    pthread_create(&tid2, NULL, selltickes, NULL);
    pthread_create(&tid3, NULL, selltickes, NULL);

    // 回收子线程资源, 阻塞
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);

    // 退出主线程
    pthread_mutex_destroy(&mutex);
    pthread_exit(NULL);
    return 0;
}
```

# 死锁

有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的信号量管理。当超过一个线程加锁**同一组互斥量**时，就有可能发生死锁。	

两个或两个以上线程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或产生了死锁。

死锁的几种场景：

- 忘记释放锁
- 重复加锁
- 多线程多锁，抢占锁资源

```c++
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 创建两个信号量
pthread_mutex_t mutex1, mutex2;

void *workA(void *arg){
    pthread_mutex_lock(&mutex1);
    sleep(1);						// 在这个过程中可能workB已经对mutex2加锁并且阻塞等待给mutex1加锁
    pthread_mutex_lock(&mutex2);	// workA阻塞等待对mutex2加锁，woerkA和workB死锁
    printf("wordA...\n");
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void *workB(void *arg){
    pthread_mutex_lock(&mutex2);
    pthread_mutex_lock(&mutex1);
    printf("wordB...\n");
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}

int main(){
    
    // 两个信号量初始化
    pthread_mutex_init(&mutex1, NULL);
    pthread_mutex_init(&mutex2, NULL);

    // 创建两个线程
    pthread_t tid1, tid2;
    pthread_create(&tid1, NULL, workA, NULL);
    pthread_create(&tid2, NULL, workB, NULL);

    // 线程分离
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    // 释放互斥量资源
    pthread_mutex_destroy(&mutex1);
    pthread_mutex_destroy(&mutex2);
    return 0;
}
```

# 读写锁

当一个线程只有持有互斥锁，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情况，当前持有互斥锁的线程只要是访问共享资源，而当同时有多个线程想进入临界区读取这个资源时，由于互斥锁有**排他性**，所有线程都无法获取锁，也就无法访问共享资源了，但实际上多个线程同时读访问共享资源也不会出现问题。

为了解决这个问题，引入了**读写锁**：

- 如果有其他线程**读**数据，则允许其他线程执行**读**操作，但不允许**写**操作。
- 如果有其他线程**写**数据，则其他线程都不允许**读**、**写**操作。
- 写是**独占**的，**写**的优先级高，写锁之后若再加读锁，则读锁需要阻塞等待，直到写锁解锁。

```c++
/*

    #include <pthread.h>

    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
    	- 读写锁的初始化
    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
    	- 读写锁销毁，回收读写锁资源
    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
    	- 尝试加写锁
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    	- 加写锁，可能会阻塞
    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    	- 加读锁，可能会阻塞
    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);	
    	- 尝试加写锁
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
		- 解锁
*/

// 案例：8个线程共享一个全局变量，3个线程不定时写一个全局变量，5个线程不定时读这个全局变量

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

static int num = 0;

// 定义互斥锁
pthread_rwlock_t lock;

void* write_num(void *arg){
    while(1){
        pthread_rwlock_rdlock(&lock);
        num++;
        printf("++write, tid: %ld, num : %d\n", pthread_self(), num);
        usleep(300);	
        pthread_rwlock_unlock(&lock);
    }
    return NULL;
}

void* read_num(void *arg){

    while(1){
        pthread_rwlock_rdlock(&lock);
        printf("==read, tid: %ld, num : %d\n", pthread_self(), num);
        usleep(300);
        pthread_rwlock_unlock(&lock);
    }

    return NULL;
}

int main(){
    
    // 互斥量初始化
    pthread_rwlock_init(&lock, NULL);

    // 创建3个写线程， 5个读线程
    pthread_t wtids[3], rtids[5];
    for (int i = 0;  i < 3; i++){
        pthread_create(wtids + i, NULL, write_num, NULL);
    }

    for (int i = 0;  i < 5; i++){
        pthread_create(rtids + i, NULL, read_num, NULL);
    }

    // 设置线程分离
    for (int i = 0; i < 5; i++){
        pthread_join(rtids[i], NULL);
    }    
    for (int i = 0; i < 3; i++){
        pthread_join(wtids[i], NULL);
    }

    pthread_rwlock_destroy(&lock);
    // 还是设置了线程等待。。。
    return 0;
}

```

# 生产者和消费者问题

生产者消费者问题中的对象：

- 生产者
- 消费者
- 容器

粗糙版生产者消费者模型（只含有互斥锁）

```c++
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

// 创建一个互斥信号量
pthread_mutex_t mutex;
// 定义共享头节点
typedef struct Node{
    int num;
    struct Node* next;
}Node;

Node* head = NULL;

void* produce(void *arg){
    while(1){
        pthread_mutex_lock(&mutex); 

        struct Node *node = (Node*)malloc(sizeof(Node));
        node->num = rand() % 1000;
        node->next = head;
        head = node;
        printf("add node, num : %d, tid : %ld\n", node->num, pthread_self());

        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

void* consume(void * arg){
    while(1){
        pthread_mutex_lock(&mutex);
        Node *tmp = head;
        if (head){  // 容器有节点
            printf("delete node, num : %d. tid : %ld\n", head->num, pthread_self());
            head = head->next;
            free(tmp);
        }
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

int main(int argc, char *argv[]){

    // 互斥量初始化
    pthread_mutex_init(&mutex, NULL);

    //创建5个生产者线程和5个消费者线程
    pthread_t producers[5], consumers[5];
    for (int i = 0; i < 5; i++) pthread_create(producers + i, NULL, produce, NULL);
    for (int i = 0; i < 5; i++) pthread_create(consumers + i, NULL, consume, NULL);

    // 设置线程分离
    for (int i = 0; i < 5; i++) pthread_detach(producers[i]);
    for (int i = 0; i < 5; i++) pthread_detach(consumers[i]);

    // 睡眠等待10秒钟，防止互斥量失效
    sleep(10);
    
    // 销毁互斥量
    pthread_mutex_destroy(&mutex);
    // 线程退出
    pthread_exit(NULL);
    
    
    return 0;
}
```

## 条件变量

```c++
/*
    #include <pthread.h>

    pthread_cond_t cond;
        - 定义条件变量
    int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);
        - 条件变量初始化
    int pthread_cond_signal(pthread_cond_t *cond);
        - 唤醒一个或多个等待的线程
    int pthread_cond_broadcast(pthread_cond_t *cond);
        - 唤醒所有等待的线程
    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
        - 等待状态，如果调用了该线程会阻塞
    int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
        - 在规定时间内等待,调用该线程会阻塞，直到规定时间结束
    int pthread_cond_destroy(pthread_cond_t *cond);
        - 条件变量销毁

*/

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

// 创建一个互斥信号量
pthread_mutex_t mutex;
// 创建一个条件变量
pthread_cond_t cond;

// 定义共享头节点
typedef struct Node{
    int num;
    struct Node* next;
}Node;

Node* head = NULL;

void* produce(void *arg){
    while(1){
        pthread_mutex_lock(&mutex); 

        struct Node *node = (Node*)malloc(sizeof(Node));
        node->num = rand() % 1000;
        node->next = head;
        head = node;
        printf("add node, num : %d, tid : %ld\n", node->num, pthread_self());
        
        // 生产一个节点，通知其他节点消费
        pthread_cond_signal(&cond);

        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

void* consume(void * arg){

    while(1){
        pthread_mutex_lock(&mutex);
        Node *tmp = head;
        if (head){  // 容器有节点
            printf("delete node, num : %d, tid : %ld\n", head->num, pthread_self());
            head = head->next;
            free(tmp);
            pthread_mutex_unlock(&mutex);
        }else{
            
            // 表中没有节点，等待生产者生产,并对已经加锁的互斥量解锁，此时该线程处于阻塞等待的状态且不消耗CPU的时间片
            // 等到阻塞结束后，线程接着执行下面的代码会对互斥量mutex重新上锁
            pthread_cond_wait(&cond, &mutex);
            pthread_mutex_unlock(&mutex);
        }
    }

    return NULL;
}

int main(int argc, char *argv[]){

    // 互斥量初始化
    pthread_mutex_init(&mutex, NULL);
    // 初始化条件变量
    pthread_cond_init(&cond, NULL);

    //创建5个生产者线程和5个消费者线程
    pthread_t producers[5], consumers[5];
    for (int i = 0; i < 5; i++) pthread_create(producers + i, NULL, produce, NULL);
    for (int i = 0; i < 5; i++) pthread_create(consumers + i, NULL, consume, NULL);

    // 设置线程分离
    for (int i = 0; i < 5; i++) pthread_detach(producers[i]);
    for (int i = 0; i < 5; i++) pthread_detach(consumers[i]);

    // 睡眠等待10秒钟，防止互斥量失效
    sleep(10);
    
    // 销毁互斥量
    pthread_cond_destroy(&cond);
    pthread_mutex_destroy(&mutex);
    // 线程退出
    pthread_exit(NULL);
    
    
    return 0;
}


```

## 信号量

```c++

/*

    #include <semaphore.h>
    int sem_init(sem_t *sem, int pshared, unsigned int value);
        - 功能：初始化信号量
        - 参数：
            - sem：信号量的地址
            - pshared：
                - 0 用于线程间
                - 非0 ：用于进程间
            - value：记录信号量中的值
    int sem_wait(sem_t *sem);
        - 对信号量加锁， 调用一次， 对信号量的值-1，如果值为0，就阻塞
    int sem_trywait(sem_t *sem);
    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
    int sem_post(sem_t *sem);
        - 对信号量解锁，调用一次对信号量的值+1，
    int sem_getvalue(sem_t *sem, int *sval);
        - 获取信号量的值
    int sem_destroy(sem_t *sem);
        - 释放信号量的资源

    
    信号量的使用(范例)：
    sem_t psem;
    sem_init(&psem, 0, 8)
    sem_t csem;
    sme_init(&csem, 0, 0);
    producer(){
        sem_wait(&psem);
        ...
        sem_post(&csem);    
    }

    consumer(){
        sem_wait(&csem);
        ...
        sem_post(&psem);
    }
*/


#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <semaphore.h>

// 创建一个互斥信号量
pthread_mutex_t mutex;

// 创建两个信号量
sem_t psem, csem;

// 定义共享头节点
typedef struct Node{
    int num;
    struct Node* next;
}Node;

Node* head = NULL;

void* produce(void *arg){
    while(1){
        // sem_wait(&psem);		// 限制链表表最长有8个节点，满8个了会阻塞等待消费者消费
        pthread_mutex_lock(&mutex); 

        struct Node *node = (Node*)malloc(sizeof(Node));
        node->num = rand() % 1000;
        node->next = head;
        head = node;
        printf("add node, num : %d, tid : %ld\n", node->num, pthread_self());

        pthread_mutex_unlock(&mutex);
        sem_post(&csem);
    }

    return NULL;
}

void* consume(void * arg){

    while(1){
        sem_wait(&csem);	
        pthread_mutex_lock(&mutex);
        Node *tmp = head;
        printf("delete node, num : %d, tid : %ld\n", head->num, pthread_self());
        head = head->next;
        free(tmp);
        pthread_mutex_unlock(&mutex);
        sem_post(&psem);
    }

    return NULL;
}

int main(int argc, char *argv[]){

    // 互斥量初始化
    pthread_mutex_init(&mutex, NULL);

    // 初始化两个信号量
    sem_init(&psem, 0, 8);
    sem_init(&csem, 0, 0);


    //创建5个生产者线程和5个消费者线程
    pthread_t producers[5], consumers[5];
    for (int i = 0; i < 5; i++) pthread_create(producers + i, NULL, produce, NULL);
    for (int i = 0; i < 5; i++) pthread_create(consumers + i, NULL, consume, NULL);

    // 设置线程分离
    for (int i = 0; i < 5; i++) pthread_detach(producers[i]);
    for (int i = 0; i < 5; i++) pthread_detach(consumers[i]);

    // 睡眠等待10秒钟，防止互斥量失效
    sleep(10);
    
    
    // 销毁信号量
    sem_destroy(&psem);
    sem_destroy(&csem);


    // 销毁互斥量
    pthread_mutex_destroy(&mutex);
    // 线程退出
    pthread_exit(NULL);
    
    
    return 0;
}


```

