---
title: 13 守护进程
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 守护进程

## 一、进程组

​	**进程组**和**会话**在进程之间形成了一种两级层次关系：进程组是一组**相关进程**的集合，会话是一组**相关进程组**的集合。

进程组和会话是为了支持shell作业控制而定义的抽象概念，用户通过shell能够交互地在前台或后台运行命令。

进程组由一个或多个**共享同一进程组标识符**(`PGID`)的进程组成。一个进程组拥有一个**进程组首进程**，该进程是创建该组的进程，其进程ID(`PID`)为该进程组的ID(`PGID`)，新进程会继承其父进程所属的进程组ID。

进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能因为终止而退出进程组，也可能因为加入另外一个进程组而退出该进程组。该进程组首进程无需是最后一个离开进程组的成员。

## 二、会话

**会话**是一组**进程组的集合**，会话首进程是创建新会话的进程。其进程ID会成为会话ID。新进程会继承父进程的会话ID。

一个会话中的**所有进程共享单个控制终端**。控制终端会在**会话首进程**首次打开一个终端设备时被建立。一个终端最多可能成为**一个会话**的控制终端。

在任一时刻，会话中的<u>其中一个进程组</u>会成为会话终端的**前台进程组**，其他进程组会成为**后台进程组**。只有前台进程组中的进程才能从终端中读取输入。当用户在控制终端中输入终端的字符生成信号后，该信号会被发送到前台进程组中的所有进程。

当控制终端的连接建立起来之后，**会话首进程**会成为该终端的**控制进程**。

## 三、进程组和会话相关的操作函数

```c++
int setpgid(pid_t pid, pid_t pgid);		// 将进程pid的组进程号设置为pgid
pid_t getpgid(pid_t pid);				// 获得pid进程的组进程ID
pid_t getsid(pid_t pid);				// 获取进程号为pid的会话进程ID
pid_t setsid(void);						// 创建新会话并指定当前进程为会话ID
```

## 四、守护进程

- 守护进程(`Daemon Process`)，也就是常说的`Daemon`进程（精灵进程），是`linux`中的后台服务进程。它是一个生存期较长的进程，通常独立于终止终端并且周期性的执行某种任务或等待处理某些发生的事。一般以`d`结尾的名字。


- 守护进程具备以下特征：
  - 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。
  - 它在后台运行并且**不拥有控制终端**。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如`SIGINT`，`SIGQUIT`）

- `linux`大多数服务器都是用守护进程实现的。比如`Internet`服务器`inetd`，`web`服务器`httpd`等。

## 五、守护进程的创建步骤

1. 执行一个`fork()`，之后父进程退出，子进程继续运行。（父进程不退出终端会显示提示符）
2. 子进程调用`setsid()`开启一个新的会话。（开启新会话不会有终端与其建立连接，这样会话不会收到终端的信号）
3. 清除进程的`umask`以确保当守护进程拥有创建文件和目录时所需的权限。
4. 修改进程的当前工作目录，通常会改为根目录(/)。
5. 关闭该守护进程**从其父进程继承而来的**所有打开着的<u>文件描述符</u>。
6. 在关闭了文件描述符0，1，2之后，守护进程通常会打开`/dev/null`并使用`dup2()`使所有这些描述符指向这些设备。
7. 核心逻辑业务。

```c++
/*
    写一个守护进程，每隔2秒获取一下系统时间，将这个时间写入到磁盘文件中。
*/

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>
#include <signal.h>
#include <time.h>
#include <string.h>

void work(int num){
    // 捕捉信号之后获取系统时间，写入磁盘文件
    time_t tm = time(NULL);
    struct tm* loc = localtime(&tm);
    char buf[1024] = {0};
    sprintf(buf, "%d-%d-%d %d:%d:%d\n", loc->tm_year + 1900, loc->tm_mon + 1, loc->tm_mday, loc->tm_hour, loc->tm_min,loc->tm_sec);
    int fdw = open("time.txt", O_RDWR | O_CREAT | O_APPEND, 0664);
    if (fdw < 0) perror("open");
    write(fdw, buf, strlen(buf));
    close(fdw);
}

int main(int argc, char *argv[]){

    // 1、创建子进程，杀死父进程
    pid_t pid = fork();
    if (pid > 0) exit(0);

    // 2、用子进程重新创建一个会话，创建新会话的原因是为了脱离控制终端
    setsid();

    // 3、设置umask
    umask(022);

    // 4、更改工作目录
    chdir("/home/chalino/文档/linux/daemon");

    // 5、关闭，重定向文件描述符
    int fd = open("/dev/null", O_RDWR);
    dup2(fd, STDIN_FILENO);
    dup2(fd, STDOUT_FILENO);
    dup2(fd, STDERR_FILENO);


    // 6、业务逻辑
        // 捕捉定时信号
        struct sigaction act;
        act.sa_flags = 0;
        act.sa_handler = work;
        sigemptyset(&act.sa_mask);
        sigaction(SIGALRM, &act, NULL);

        // 创建定时器
        struct itimerval timer_ds;
        timer_ds.it_interval.tv_sec = 2;
        timer_ds.it_interval.tv_usec = 0;
        timer_ds.it_value.tv_sec = 2;
        timer_ds.it_value.tv_usec = 0;

        setitimer(ITIMER_REAL, &timer_ds, NULL);

    while(1){
        sleep(10);
    }
    return 0;
}
```

