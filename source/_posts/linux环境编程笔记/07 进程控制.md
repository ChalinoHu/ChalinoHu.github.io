---
title: 07 进程控制
date: 2022-05-27 21:02:46
tags: linux环境编程
---

# 进程



## 1、程序和进程

程序是包含一系列信息的文件，这些文件描述了如何在运行时创建一个进程。

进程时正在运行程序的实例，是一个具有独立功能的程序关于某个数据集合的一次运行活动，是操作系统动态执行的基本单元，传统操作系统中，进程既是基本的**分配**单元，也是基本的**执行**单元。

可用一个程序创建多个进程，进程是由**内核**定义的抽象实体，并为该实体<u>分配供程序执行所需的各种系统资源</u>。

进程由**用户内存空间**和一系列**内核数据结构**构成，其中**用户内存空间**包含程序代码及代码所使用的变量，而**内核数据结构**用来维护进程的状态信息（相关**标识号**， **虚拟内存表**、打开的**文件描述符**，**信号**传递与处理相关的信息，进程资源使用及限制，**当前工作目录**等信息）。

```shell
ulimit -u 			# 查看系统中最大进程数
```



## 2、进程的状态转换

进程的状态有三态模型（就绪态、运行态、阻塞态）和五态模型（新建态、就绪态、运行态、组赛态、结束态）

**运行态**：进程占有处理器正在运行

**就绪态**：具备运行的条件，具有除CPU以外的所有资源，只要分配CPU后就可运行从而转为运行态。有时处于就绪状态的进程有很多，一般将它们排成队列，称为就绪队列

**阻塞态**：该进程不具备运行的条件，等待着某个事件的完成

![](/images/image/进程状态.png)

五态模型增加了新建态和终止态，这样更符合进程的生命周期。

**新建态**：创建时尚未进入到就绪状态。

**终止状态**：进程正常的任务结束，或者由于某种无法克服的错误而异常终止，或被操作系统有终止权的进程所终止所处的状态。进入终止状态后的进程不再执行，依然保存在操作系统中，一旦其他进程完成了对终止态进程的信息抽取之后操作系统再删除该进程。

![](/images/image/五态模型.png)

## 3、进程相关的Linux命令

### 3.1 `ps`	显示进程的快照

```shell
ps aux 
ps jux
```

其中

```
a 显示终端中的所有进程，包括其他用户的进程
u 显示进程的详细信息
x 显示没有控制终端的进程
j 列出与作业控制相关的信息
```

### 3.2 `top`	实时显示进程动态

可以在top命令执行后可通过以下按键对显示结果进行排序

```
M 内存使用量进行排序
P CPU占有率进行排序
T 进程运行时间长短进行排序
U 根据用户名来筛选进程
K 输入指定的PID来杀死进程
```

### 3.3 `kill` 杀死进程

```shell
kill [-signal] pid_t	# 杀死pid为pid_t的进程
kill -l		# 查看Linux系统中所有的信号
kill -9 pid_t	# 强制杀死pid_t的进程
kill -SIGKILL 进程ID	# 强制杀死pid_t的进程
killall name	# 根据进程名杀死进程
```

## 4、进程号和相关函数

每个进程由**进程号**来标识（`PID`），类型为`pid_t`，进程号的范围**0~32767**，进程号是动态分配的，进程号总是唯一的但是可以重用。当一个进程终止后，其进程号可以重新使用。

除了`init`进程外，任何进程都是由另一个进程创建的，该进程为被创建进程的**父进程**，对应进程号为父进程号（`PPID`）

进程组是一个或者多个进程的集合，它们之间相互关联，可接受同一终端的各种信号，关联的进程有一个**进程组号**（`PGID`）默认情况下当前的进程号会被当作进程组号。

进程号和进程组号的相关函数：

```c
pid_t getpid(void);
pid_t getppid(void);
pid_t getpgid(pid_t pid);
```

## 5、创建进程

###  `fork`

```c
/*
#include <unistd.h>
#include <sys/types.h>

pid_t fork(void);
    作用：创建一个子进程
    返回值：fork的返回值会返回两次，一次是在父进程中，一次是在子进程中。
        在父进程中返回子进程的pid，子进程中返回0, 因此可通过fork的返回值区分父进程和子进程
        父进程中返回-1表示进程创建失败，并且设置errno
        进程返回失败的原因可能如下：
            1、当前的进程数达到系统规定的上限，errno设置为EAGAIN
            2、系统内存不足，errno设置为ENOMEM

*/

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char *argv[]){

    // 创建子进程
    pid_t pid = fork();

    if (pid > 0){
        // 返回创建子进程的进程号，当前是父进程
        printf("pid:%d\n", pid);
        printf("I am parent process, pid:%d, ppid:%d\n",getpid(), getppid());

    }else if (pid == 0){
        //当前是子进程
        printf("I am child process, pid:%d, ppid:%d\n", getpid(), getppid());
    }else {
        // 进程创建失败
        perror("fork");
    }

    for (int i = 0; i != 3; ++i){
        printf("i:%d, pid:%d\n", i, getpid());
        sleep(1);
    }
    return 0;
}
```

![](/images/image/fork.png)

`fork`之后子进程会复制一份父进程的虚拟地址空间，两者的内存空间相互独立，并具有相同的内容，除`pid`外其他内容均相同。

## 6、父子进程关系及`GDB`多进程调试

### 6.1父子进程之间的关系：

区别：

​	1、`fork`函数的返回值不同，父进程中返回值大于0（子进程的ID），子进程中返回值为0

​	2、PCB中的一些数据不同，如`pid`, `ppid`,信号集

共同点：

某些状态下，子进程刚被创建出来并且还没有执行任何写数据的操作时（写时拷贝技术），**用户区的数据**、**文件描述符表**时一样的。

父子进程对变量的共享：**读时共享（子进程刚被创建，两个进程没有做写的操作），写时拷贝**。

### 6.2 `GDB`多进程调试

使用多进程调试时，`GDB`默认只能跟踪一个进程，可在`fork`函数调用之前，使用指令设置**`GDB`调试工具**跟踪父进程或者是跟踪子进程，默认跟踪父进程。

**设置调试跟踪父进程或子进程**：`set follow-fork-mode [parent(默认) | child]`

**设置调式模式**：`set detach-on-fork [on | off]`	默认为`on`，表示调试当前进程时，其他进程继续运行；如果设置为`off`，表示调试当前进程时，其他进程被挂起。

**查看调试的进程**：`info inferiors`	

**切换当前调试的进程**：`inferior id`

**使进程脱离`GDB`调试**：`detach inferiors id`

## 7、exec函数族

exec函数族的作用主要是根据指定的文件名来找到可执行文件。并通过指定文件中的内容来取代调用进程的内容，换句话说就是在调用进程内部执行一个可执行程序。一般是先创建一个子进程，然后通过调用exec函数族来替换子进程中的内容，让子进程去做别的事情。

exec函数族的函数调用成功后不会返回，因为调用进程的实体，包括代码段、数据段和堆栈都已经被新的内容取代，只留下进程ID等一些表面信息保持原样。exec函数族调用失败了返回-1，并从原程序的调用点接着往下执行。

```c++
// exec函数族的函数
#include <unistd.h>

extern char **environ;

int execl(const char *path, const char *arg, ...
/* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
/* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
/*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
                       char *const envp[]);	
函数族后缀的意义：
    l(list): 参数地址列表，以空指针结尾
    v(vector):存有各参数地址的指针数组的地址
    p(path):按照PATH环境变量指定的目录搜索可执行文件
    e(environment):存有环境变量字符串地址的指针数组的地址，该环境变量由自己指定
```



```c++
/*

#include <unistd.h>


int execl(const char *path, const char *arg, ...);
    参数：
        - path:需要执行的指定的文件的路径或名称，推荐使用绝对路径
        - args:执行可执行文件内容所需要的参数

        第一个参数没有实际意义，为了方便一般写可执行文件的名称；
        从第二个参数开始就是程序执行所需要的参数列表，参数最后需要以NULL结束（哨兵）

    返回值：
        只有当调用失败才会有返回值，返回-1，并且设置errno
        如果调用成功就没有返回值（因为调用成功后代码区的内容被替换，因此不会执行之前的代码了）


int execlp(const char *path, const char *arg, ...);
    和execcl函数相同，path是从环境变量中寻找，其他路径的文件是找不到的。

*/

#include <unistd.h>
#include <stdio.h>

int main(int argc, char *argv[]){

    pid_t pid = fork();

    if (pid > 0){
        printf("I am parent process\n");
        sleep(1);
    }else if (pid == 0){
        execl("hello", "hello",NULL);
        printf("I am child process\n");
    }

    for (int i = 0; i < 3; i++){
        printf("i = %d, pid = %d\n", i,getpid());
    }
    
    return 0;
}
```

hello程序主要执行的功能是打印一句“hello， world”

![](/images/image/execl.png)

## 8、进程控制

### 8.1、进程退出

进程的退出主要有两个函数:

```c++
#include <stdlib.h>
void exit(int status);
    
#include <unistd.h>
void _exit(int status);
```

两个函数的区别：

![](/images/image/exit.png)

### 8.2、孤儿进程

孤儿进程：父进程运行结束，但子进程依然在运行，这样的子进程被称为孤儿进程。

每当出现一个孤儿进程的时候，内核会将孤儿进程的父进程设置成`init`，而`init`会循环的wait()它的已经退出的子进程，这样当一个孤儿进程结束其生命周期后，`init`进程会出面处理善后工作。因此孤儿进程不会有什么危害，最终都会父进程（或`init`进程）被回收。

演示实例：

```c++
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char *argv[]){

    // 创建子进程
    pid_t pid = fork();

    if (pid > 0){
        // 返回创建子进程的进程号，当前是父进程
        printf("I am parent process, pid:%d, ppid:%d\n",getpid(), getppid());

    }else if (pid == 0){
        //当前是子进程
        sleep(1);   //等待父进程结束
        printf("I am child process, pid:%d, ppid:%d\n", getpid(), getppid());
    }else {
        // 进程创建失败
        perror("fork");
    }


    for (int i = 0; i != 3; ++i){
        printf("i:%d, pid:%d, ppid:%d\n", i, getpid(), getppid());
    }
    return 0;
}
```

![](/images/image/orphan.png)

子进程暂停给一秒，等父进程结束后变为孤儿进程，`init`进程被设置为该孤儿进程的父进程。

### 8.3 僵尸进程

每个进程结束之后都会释放自己**用户空间**中用户区数据，**内核区的PCB没办法自己释放掉**，需要由父进程来进行释放。而当某个进程终止时，其父进程尚未对其回收，**子进程残留资源(PCB)存放于内核中**，变成僵尸进程(zombie)。

僵尸进程不能被kill -9杀死。

僵尸进程的危害：

如果父进程不调用`wait()`或`waitpid()`，那么保留的这段信息(PCB)就不会被释放，其进程号就会一直被占用。但是系统中能提供的进程号时有限的，如果产生大量的僵尸进程，将会因为没有可用的进程号而导致系统没有产生新的进程，此即为僵尸进程的危害，应当避免。

```c++
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char *argv[]){
    
    pid_t pid = fork();
    
    if (pid > 0){
        printf("我是父进程: pid : %d, ppid : %d\n", getpid(), getppid());
        while(1){	//  父进程一直循环，子进程结束后父进程没有wait()或者waitpid()释放子进程。
            sleep(1);
        }
    }
    else if (pid == 0){
        printf("我是子进程: pid : %d, pppid : %d\n", getpid(), getppid());
    }


    for (int i = 0; i < 3; i++){
        printf("i = %d, pid : %d, ppid : %d\n", i, getpid(), getppid());
    }
}
```

![](/images/image/zombie.png)

### 8.4、进程回收

每个进程退出时，内核释放该进程的所有资源，包括打开的文件、占用的内存等，这些资源大部分是用户空间的资源。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号，退出状态、运行时间等）。

父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。

`wait()`和`waitpid()`函数的功能一样，区别在于`wait`函数会阻塞，`waitpid`可以设置不阻塞，`waitpid()`可以指定等待哪个子进程结束。

注意：一次`wait()`和`waitpid()`调用只能清理一个子进程，清理多个子进程应使用循环。

退出信息相关的宏函数：

```c++
// 判断进程是否正常退出
WIFEXITED(status);      //非0， 进程正常退出
WEXITSTATUS(status);    //如果上宏为真，获取进程退出的状态(exit的参数)

// 进程是否是被信号杀死的
WIFSIGNALED(status);    // 非0，进程异常终止
WTERMSIG(status);       // 如果上宏为真，获取使进程终止的信号编号

WIFSTOPPED(status);     // 非0，进程处于暂停状态
WSTOPSIG(status);       // 如果上宏为真，获取进程暂停的信号的编号
WIFCONTINUED(status);   //非0.进程暂停后已经继续运行
```

```c++
/*
    #include <sys/types.h>
    #include <sys/wait.h>
    
    pid_t wait(int *wstatus);
    作用：等待任意一个子进程结束，如果任意一个子进程结束了，子函数就会回收子进程
    参数：int *wstatus 
        进程退出时的状态信息，传入的是一个int类型的地址，是一个传出参数
    返回值：
        -成功：返回被成功回收的子进程的pid
        -失败：-1 (两个意思：1、所有的子进程都结束了，调用函数失败)

    调用wait函数的基础南横将会被挂起(阻塞)，直到它的一个子进程退出或者收到一个不能被忽略的信号才被唤醒，继续往下执行。
    如果没有子进程了，函数立刻返回，返回-1 ; 如果子进程都已经结束了，也会立即返回-1
*/

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>

int main(int argc, char *argv[]){

    pid_t pid;
	
  	// 创建两个进程
    for(int i = 0; i < 5; i++){
        pid = fork();

        if (pid == 0){
            break;
        }
    }
   
    if (pid > 0){
        // 父进程
        while(1){
            printf("parent, pid = %d\n", getpid());
            int status;
            int ret = wait(&status); // 子进程结束前是阻塞状态
            if (ret == -1){
                break;
            }
            if (WIFEXITED(status)){
                printf("进程退出状态码为: %d\n", WEXITSTATUS(status));
            }
            if (WIFSIGNALED(status)){
                printf("被信号 %d 干掉了\n", WTERMSIG(status));
            }
            
            printf("child die, pid = %d\n", ret);

            sleep(1);
        }
 
    }else if (pid == 0){
        while(1){
            printf("child, pid = %d\n", getpid());
            sleep(1);
        }
        exit(1);
    }

    return 0;
}
```

```c++
/*
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t waitpid(pid_t pid, int *wstatus, int options);
            功能：回收指定进程号的子进程，可以设置是否阻塞。
            参数：
                pid：
                    pid > 0:要回收的子进程的pid
                    pid = 0:回收当前进程组的所有子进程
                    pid = -1:回收所有子进程，相当于wait(), 最常使用
                    pid = <-1:回收pgid等于当前给定值的绝对值相等的进程组的所有子进程
                options：
                    0:阻塞
                    WNOHANG:非阻塞
            返回值：
                > 0:返回回收的子进程的pid
                = 0:options = WNOHANG，表示还有子进程活着
                -1 :调用函数失败或者没有子进程了

*/

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>


int main(int argc, char *argv[]){

    int pid;

    // 创建5个进程
    for (int i = 0; i < 5; i++){
        pid = fork();
        if (pid == 0){	//若是子进程不接着执行代码段中fork的程序
            break;
        }
    }

    if (pid > 0){
        // waitpid()
        while(1){

            printf("I am parent, pid = %d\n", getpid());
            sleep(1);

            int status;
            int ret = waitpid(-1, &status, WNOHANG);
            
            if (ret == 0){  // 子进程没有被回收，接着循环查询子进程的状态
                continue;
            }
            else if (ret > 0){   // 成功回收一个进程
                printf("成功回收进程%d\n", ret);

                if (WIFEXITED(status)){
                    printf("进程退出状态值为: %d\n", WEXITSTATUS(status));
                }
                if (WIFSIGNALED(status)){
                    printf("被信号%d干掉了\n",WTERMSIG(status));
                }

            }
            else if (ret == -1){
                break;
            }

        }
        
    }else if (pid == 0){
        while(1){
            printf("I am child, pid = %d\n", getpid());
            sleep(1);
        }
        exit(0);
    }

    return 0;
}
```
