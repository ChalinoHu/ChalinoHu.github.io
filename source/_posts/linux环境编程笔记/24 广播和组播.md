---
title: 24 广播和组播
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 广播和组播

## 广播

> 向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标部分的二进制全部为1。
>
> a.只能在局域网中使用。
>
> b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。

```c
// 设置socket的广播属性
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
	- sockfd:
	- level: SOL_SOCKET
    - optname:SO_BROADCAST
	- optval: int类型的值， 1为允许广播
    - optlen: optval的大小
```

```c
// 广播服务端

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <string.h>

int main(){

    // 创建socket
    int fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (fd == -1){
        perror("socket");
        exit(-1);
    }

    // 设置广播属性
    int op = 1;
    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &op, sizeof op);

    // 创建一个广播的地址
    struct sockaddr_in cliaddr;
    cliaddr.sin_family = AF_INET;
    cliaddr.sin_port = htons(9999);
    inet_pton(AF_INET, "192.168.198.255", &cliaddr.sin_addr.s_addr);

    // 通信
    while (1){
        
        static int num = 0;
        char buf[128] = {0};
        sprintf(buf, "hello, client... %d\n", num++);
        // 发送数据
        sendto(fd, buf, strlen(buf) + 1, 0, (struct sockaddr*)&cliaddr, sizeof cliaddr);
        
        // 广播的数据
        printf("广播的数据: %s\n", buf);
        sleep(1);
    }
    
    close(fd);
    return 0;
}
```

```c
// 广播客户端

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <string.h>

int main(){

    // 创建socket
    int fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (fd == -1){
        perror("socket");
        exit(-1);
    }

    // 客户端绑定本机主机和端口
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9999);
    inet_pton(AF_INET, "0.0.0.0", &addr.sin_addr.s_addr);  

    int ret = bind(fd, (struct sockaddr *)&addr, sizeof addr);
    if (ret == -1){
        perror("bind");
        exit(-1);
    }

    // 通信
    while (1){

        char buf[128] = {0};

        // 接收数据
        ret = recvfrom(fd, buf, sizeof buf, 0, NULL, NULL);
        if (ret == -1){
            perror("recvfrom");
            exit(-1);
        }

        // 打印接收的数据
        printf("recv data : %s\n", buf);

    }
    
    close(fd);
    return 0;
}
```



## 组播（多播）

> 单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。
>
> a.组播既可以用于局域网，也可以用于广域网
>
> b.客户端需要加入多播组，才能接收到多播的数据

组播地址

> P 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从 224.0.0.0 到 239.255.255.255 ，
>
> 并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:

<img src="/images/image/组播地址.png" style="zoom:50%;" />

```c
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);

    // 服务器设置多播的信息，外出接口
        - level: IPPROTO_IP
        - optname: IP_MULTICAST_IF
        - optval: struct in_addr

    // 客户端加入到多播组:
        - level: IPPROTO_IP
        - optname: IP_ADD_MEMBERSHIP
        - optval: struct ip_mreqn
```

```c

// 组播服务端

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <string.h>

int main(){

    // 创建socket
    int fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (fd == -1){
        perror("socket");
        exit(-1);
    }

    // 设置多播属性，设置外出接口
    struct in_addr op;
    // 初始化多播地址
    inet_pton(AF_INET, "239.0.0.10", &op.s_addr);
    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &op, sizeof op);

    // 初始化客户端的地址信息
    struct sockaddr_in cliaddr;
    cliaddr.sin_family = AF_INET;
    cliaddr.sin_port = htons(9999);
    inet_pton(AF_INET, "239.0.0.10", &cliaddr.sin_addr.s_addr);

    // 通信
    while (1){
        
        static int num = 0;
        char buf[128] = {0};
        sprintf(buf, "hello, client... %d\n", num++);
        // 发送数据
        sendto(fd, buf, strlen(buf) + 1, 0, (struct sockaddr*)&cliaddr, sizeof cliaddr);
        
        // 组播的数据
        printf("组播的数据: %s\n", buf);
        sleep(1);
    }
    
    close(fd);
    return 0;
}
```

```c

// 组播客户端

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <string.h>

int main(){

    // 创建socket
    int fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (fd == -1){
        perror("socket");
        exit(-1);
    }

    // 客户端绑定本机主机和端口
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9999);
    addr.sin_addr.s_addr = INADDR_ANY;
    int len = sizeof addr;
    int ret = bind(fd, (struct sockaddr *)&addr, sizeof addr);
    if (ret == -1){
        perror("bind");
        exit(-1);
    }

    struct ip_mreq op;
    inet_pton(AF_INET, "239.0.0.10", &op.imr_multiaddr);
    op.imr_interface.s_addr = INADDR_ANY;
    // 加入到多播组
    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &op, sizeof op);

    // 通信
    while (1){

        char buf[128] = {0};

        // 接收数据
        ret = recvfrom(fd, buf, sizeof buf, 0, NULL, NULL);
        if (ret == -1){
            perror("recvfrom");
            exit(-1);
        }

        // 打印接收的数据
        printf("recv data : %s\n", buf);

    }
    
    close(fd);
    return 0;
}


```

