---
title: 11 信号
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 信号

[TOC]



## 一、概述

简介

- 信号是Linux系统最古老的进程间通信方式之一，是事件发生时对进程的通知机制。有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信方式。信号可以导致一个正在运行的进程被正在运行的另一个异步进程中断，转而处理某一个突发事件。

- 发送进程的诸多信号，通常都是源于内核。引发内核为进程发送信号的各类事件如下：
  - 对于前台进程，用户可以通过输入特殊的终端字符来给它发信号，比如`Ctrl + C`通常会给进程发送一个终止信号。	
  - 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即将由内核发送信号给相关进程。比如执行一条异常的机器指令语句，诸如被0除或引用了无法访问的内存区域。
  - 系统状态变化，比如`alarm`定时器到期将引起`SIGALRM`信号，进程执行的`CPU`时间超限或者该进程的某个子进程退出。
  - 运行`kill`命令或调用`kill`函数。

使用信号的两个目的：

- 让进程知道已经发生了一个特定的是事情
- 强迫进程执行它自己代码中的信号处理程序

信号的特点：

- 简单
- 不能携带大量信息
- 满足某个条件才发送
- 优先级比较高

查看系统定义的信号列表：`kill -l`，前31个为常规信号，其余为实时信号

**重点信号**

| 序号 | 名称      | 默认动作                   | 相应事件                                     |
| ---- | --------- | -------------------------- | -------------------------------------------- |
| 2    | `SIGINT`  | 终止进程                   | 来自键盘的中断                               |
| 3    | `SIGQUIT` | 终止进程                   | 来自键盘的退出                               |
| 9    | `SIGKILL` | 杀死进程，可以杀死任何进程 | 无条件终止进程，该信号不能被忽略，处理和阻塞 |
| 11   | `SIGSEGV` | 终止进程并产生`core`文件   | 指示进程进行了无效的内存引用（段错误）       |
| 13   | `SIGPIPE` | 终止进程                   | Broken， pipe向一个没有读端的管道写数据      |
| 14   | `SIGALRM` | 终止进程                   | 来自alarm函数的定时器信号                    |
| 17   | `SIGCHLD` | 忽略这个信号               | 子进程结束时，父进程会收到这个信号           |
| 18   | `SIGCONT` | 忽略/继续                  | 如果进程停止，则使其继续运行                 |
| 19   | `SIGSTOP` | 为终止进程                 | 停止进程的执行。信号不能忽略、处理和阻塞     |

**信号的5中默认处理动作**

**查看信号的详细信息**：`man 7 signal`

**信号的5种默认处理动作**：

- `Term`：终止进程
- `Ign`：当前进程忽略掉这个信号
- `Core`：终止进程，并生成一个Core文件（用来保存产生错误的信息）
- `Stop`：暂停当前进程
- `Cont`：继续执行当前被暂停的进程

信号的几种状态：产生、未决（没有送达到进程）、抵达（到达进程并被处理）

`SIGKILL`和`SIGSTOP`信号不能被捕获、阻塞或忽略，只能执行默认动作

## 二、信号相关的一些函数

### `int kill(pid_t pid, int sig);`

### `int raise(int sig);`

### `void abort(void);`

```c++
/*
    #include <sys/types.h>
    #include <signal.h>

    int kill(pid_t pid, int sig);
    功能：给某个进程pid，发送某个信号sig，sig为发送信号的编号或者   宏值
    参数：
        -pid：
            > 0:将信号发送给指定的进程ID
            = 0:将信号发送给当前进程组的所有进程
            = -1:将信号发送给每一个有权限接收该信号的进程
            < -1:将信号发送给指定进程组号为-pid的进程组中所有的进程
        -sig：
            = 0:没有信号发送
    返回值:
        成功: 0
        失败: -1 ,设置errno
        kill(getpid(), sig);


    #include <signal.h>
    int raise(int sig);
    功能：给当前进程发送信号
    参数:
        -sig: 要发送的信号
    返回值:
        - 成功: 0
        - 失败: 非0
    
    相当于 kill(getpid(), sig);, kill(getppid(), sig);

    
    #include <stdlib.h>
    void abort(void);   
    功能: 发送SIGABRT给当前进程，杀死当前进程
    相当于:kill(getpid(), SIGABRT);

*/


// 简单演示kill

#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[]){

    pid_t pid = fork();

    if (pid > 0 ){
        // 父进程
        printf("parent process\n");
        sleep(2);
        printf("kill child process\n");
        kill(pid, SIGINT);
    } else if (pid == 0){
        // 子进程
        for (int i = 0; i < 10; i++){
            printf("child process\n");
            sleep(1);
        }
    }else {
        perror("fork");
        exit(0);
    }
    return 0;
}
```

![](/images/image/kill.png)

### `unsigned int alarm(unsigned int seconds);`

```c++
/*
    #include <unistd.h>
    unsigned int alarm(unsigned int seconds);
        功能:设置定时器，函数调用倒计时，当计时为0时，函数会给当前进程发送一个信号SIGALRM
        参数: 
            - seconds:倒计时的时长，单位:秒,如果定时器为0，定时器无效(不进行倒计时，不发信号)
            取消一个定时器，通过alarm(0)
        返回值: 
            之前没有定时器：返回 0
            之前有设置定时器：返回之前定时器倒计时剩余的时间
            如：alarm(10) 返回0
                过了1秒
                alarm(5) 返回9
    
    SIGALARM : 默认终止当前的进程，每个进程都有且只有唯一的一个定时器
    
    alarm(100): 该函数是不阻塞的，该函数会一直执行。
    
    定时器，与进程的状态无关（自然定时法）无论进程处于什么样的状态，都会计时
*/


#include <unistd.h>
#include <stdio.h>

int main(int argc, char *argv[]){

    int seconds = alarm(5);
    printf("%d\n", seconds);
    sleep(2);
    seconds = alarm(2);
    printf("%d\n", seconds);
    while(1);
    return 0;
}
```

![](/images/image/alarm.png)

### `int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);`

```c++
/*
       #include <sys/time.h>
       int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
        功能:设置定时器，可以替代alarm函数。 精度:微秒us，可以实现周期性定时。

        参数:
            - which : 以什么时间计时
                - ITIMER_REAL: 系统运行的真实时间，包含系统时间，用户时间以及其他操作如IO消耗的时间
                    每次时间到达，发送SIGALRM信号，是常用的参数。
                - ITIMER_VIRTUAL: 用户态时间，时间到达，发送SIGVTALRM信号。
                - ITIMER_PROF: 以该进程在用户态和内核态消耗的时间来计算，时间到达发送SIGPROF信号

            - new_value : 设置定时器的属性

                struct itimerval {      // 定时器的结构体
                    struct timeval it_interval;     // 每个阶段的时间，间隔时间
                    struct timeval it_value;        // 延迟多长时间执行定时器
                };

                struct timeval {            // 时间的结构体
                    time_t      tv_sec;     // 秒
                    suseconds_t tv_usec;    // 微秒
                };
                如:过10秒后，每隔2秒定时一次：it_value 设置为 10秒, it_interval 设置为2秒
            
            - old_value : 记录上一次定时的时间参数，一般不使用，指定NULL
        
        返回值:
            - 成功 : 0
            - 失败 : -1，设置errno
*/

#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>

// 过3秒钟之后，每隔2秒钟定时一次
int main(int argc, char *argv[]){

    struct itimerval new_value;

    // 设置间隔时间（周期性发送信号的时间）
    new_value.it_interval.tv_sec = 2;
    new_value.it_interval.tv_usec = 0;

    // 设置延迟时间
    new_value.it_value.tv_sec = 3;
    new_value.it_value.tv_usec = 0;

    int ret = setitimer(ITIMER_REAL, &new_value, NULL);     // 非阻塞的
    if (ret == -1){
        perror("setitimer");
        exit(0);
    }
    
    getchar();
    return 0;
}
```

### `sighandler_t signal(int signum, sighandler_t handler);`

```c++
/*

       #include <signal.h>

       typedef void (*sighandler_t)(int);   // 信号处置函数

       sighandler_t signal(int signum, sighandler_t handler);
        -功能：设置某个信号的捕捉行为
        -参数：
            - signum：要捕捉的信号，一般使用宏值
            - handler：捕捉的信号要如何处理
                - SIG_IGN: 忽略该信号
                - SIG_DFL: 使用信号的默认行为   
                - 信号处理函数: 该函数为回调函数。这个函数是内核去调用的，程序员只负责去写
        
        -返回值:
            - 成功：返回上一次注册的回调函数（信号处理函数）的地址，第一次调用返回NULL
            - 失败：返回SIG_ERR，设置错误号


        SIGKILL和SIGSTOP不能被捕捉，也不能被忽略
        	假设一种情况:如果sigkill能捕获，那么如果我们写一段程序捕捉到了SIGKILL信号，但是什么都不做，那么			此时SIGKILL信号就相当于SIG_IGN,所有的SIGKILL都无法终止此进程，等同SIGKILL信号失效。同理SIGSTOP也是如此。

*/

#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>


void signal_hander(int num){
    printf("捕捉到的信号的编号是: %d\n", num);
}

// 过3秒钟之后，每隔2秒钟定时一次
int main(int argc, char *argv[]){

    // 设置信号捕捉
    // signal(SIGALRM, SIG_IGN);   // 忽略该信号
    // signal(SIGALRM, SIG_DFL);   // 信号的默认行为，SIGALRM默认行为是终止进程


    // void (*sighandler_t)(int num);   // num表示捕捉到的信号的值   
    __sighandler_t rt = signal(SIGALRM, signal_hander);
    if (rt == SIG_ERR){
        perror("signal");
        exit(0);
    }
    
    struct itimerval new_value;

    // 设置间隔时间（周期性发送信号的时间）
    new_value.it_interval.tv_sec = 2;
    new_value.it_interval.tv_usec = 0;

    // 设置延迟时间
    new_value.it_value.tv_sec = 3;
    new_value.it_value.tv_usec = 0;

    int ret = setitimer(ITIMER_REAL, &new_value, NULL);     // 非阻塞的
    if (ret == -1){
        perror("setitimer");
        exit(0);
    }

    getchar();
    return 0;
}
```

设置3秒后每隔2秒发送一次信号，自定义信号处置函数来对处置信号。

![](/images/image/signal.png)

## 三、信号集

许多信号相关的系统调用都希望能表示一组不同的信号，多个信号可使用一个称之为**信号集**的数据结构来表示，其系统数据类型为**`sigset_t`**。

PCB中有两个非常重要的信号集，分别为**阻塞信号集**和**未决信号集**。这两个信号集都是内核使用**位图机制**实现的。但操作系统不允许我们直接对这两个信号集进行**位操作**。而需自定义另外一个集合，借助信号集操作函数来对PCB中的两个信号进行修改。

信号的**未决**是一种状态：表示信号从产生到信号被处理前的这一段时间。

信号的**阻塞**是一个开关动作：值的是组织信号被处理，但不阻止信号的产生。

信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下阻塞信号只是暂时的，只是为了防止信号打断敏感的操作。

## 四、信号集相关的一些函数

### `int sigemptyset(sigset_t *set);`

### `int sigfillset(sigset_t *set);`

### `int sigaddset(sigset_t *set, int signum);`

### `int sigdelset(sigset_t *set, int signum);`

### `int sigismember(const sigset_t *set, int signum);`

```c++
/*

        以下信号集相关的函数都是对自定义的信号集进行操作
       #include <signal.h>

       int sigemptyset(sigset_t *set);
        - 功能：清空信号集中的数据，将信号集中所有的标志位置为0，
        - 参数：
            - set：需要操作的信号集，传出参数
        - 返回值：
            - 成功：0
            - 失败：-1 ，设置errno

       int sigfillset(sigset_t *set);
        - 功能：将信号集中所有的标志位置为1，
        - 参数：
            - set：需要操作的信号集，传出参数
        - 返回值：
            - 成功：0
            - 失败：-1 ，设置errno

       int sigaddset(sigset_t *set, int signum);
        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号
        - 参数：
            - set：需要操作的信号集，传出参数
            - signum：设置阻塞的那个信号
        - 返回值：
            - 成功：0
            - 失败：-1 ，设置errno

       int sigdelset(sigset_t *set, int signum);
        - 功能：设置信号集中的某一个信号对应的标志位为1，表示不阻塞这个信号
        - 参数：
            - set：需要操作的信号集，传出参数
            - signum：设置不阻塞的那个信号
        - 返回值：
            - 成功：0
            - 失败：-1 ，设置errno

       int sigismember(const sigset_t *set, int signum);
        - 功能：判断这个信号是都属于该信号集，判断该信号是否阻塞
        - 参数：
            - set：需要操作的信号集
            - signum：需要判断的那个信号
        - 返回值：
            - 1：表示signum被阻塞
            - 0：表示signum不阻塞
            - -1：错误，设置errno

*/

#include <signal.h>
#include <stdio.h>
#include <unistd.h> 
#include <stdlib.h>

int main(int argc, char *argv[]){

    // 1、创建一个信号集
    sigset_t set;

    // 2、清空信号集
    sigemptyset(&set);

    // 3、判断SIGINT是否在信号集set里
    int ret = sigismember(&set, SIGINT);
    if (ret == 0){
        printf("%d 不阻塞\n", SIGINT);
    }else if (ret == 1){
        printf("%d 阻塞\n", SIGINT);
    }else if (ret == -1){
        perror("sigismember");
        exit(0);
    }

    // 4、添加几个信号到信号集中
    sigaddset(&set, SIGINT);
    sigaddset(&set, SIGQUIT);
    sigaddset(&set, SIGALRM);

    // 5、判断SIGINT是否在信号集set里
     ret = sigismember(&set, SIGINT);
    if (ret == 0){
        printf("%d 不阻塞\n", SIGINT);
    }else if (ret == 1){
        printf("%d 阻塞\n", SIGINT); 
    }else if (ret == -1){
        perror("sigismember");
        exit(0);
    }

    // 6、从信号集中删除一个信号
    sigdelset(&set, SIGQUIT);

    // 7、判断SIGQUIT是否在信号集中
     ret = sigismember(&set, SIGQUIT);
    if (ret == 0){
        printf("%d 不阻塞\n", SIGQUIT);
    }else if (ret == 1){
        printf("%d 阻塞\n", SIGQUIT); 
    }else if (ret == -1){
        perror("sigismember");
        exit(0);
    }

    return 0;
}
```

![](/images/image/signalset.png)

### `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`

### `int sigpending(sigset_t *set);`

```c++
/*
    #include <signal.h>
    
    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，接触阻塞，替换）
        - 参数：
            - how：如何对内核信号集进行处理
                - SIG_BlOCK：将用户设置的阻塞信号集添加到内核中， 内核中原来的数据不变。
                    假设内核中默认的阻塞信号集是mask，mask | set
                - SIG_UNBLOCK：根据用户设置的数据，对内核中的数据进行解除阻塞。
                    mask & ~set
                - SIG_SETMASK：覆盖内核中原来的值
            
            - set：已经初始化好的用户自定义的信号集

            - oldset：保存设置之前内核中的在阻塞信号集的状态，可以是NULL
        - 返回值：
            - 成功：0
            - 失败：-1，设置errno， 分别有EFAULT(set和oldset的地址非法)和EINVAL(指定的how非法)

    int sigpending(sigset_t *set); 
        - 功能：获取内核中的未决信号集
        - 参数：set，传出参数，保存的是信号集中的未决信号集
        - 返回值：成功：0. 失败-1, 设置errno

*/ 

// 编写一个程序，将所有的常规信号（1 - 31）未决状态打印出屏幕
//  设置某些信号是阻塞的，通过键盘产生这些信号

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char *argv[]){

    int num = 0;
    // 设置2、3号信号阻塞
    sigset_t set;
    sigemptyset(&set);

    // 将2号和3号信号添加到信号集中
    sigaddset(&set, SIGINT);
    sigaddset(&set, SIGQUIT);

    // 修改内核中的阻塞信号集
    sigprocmask(SIG_BLOCK, &set, NULL);

    while(1){
        ++num;
        sleep(1);
        // 获取当前未决信号集的数据
        sigset_t pendingset;
        sigemptyset(&pendingset);
        sigpending(&pendingset);
        

        // 遍历前32位
        for (int i = 1; i < 32; i++){
            if (sigismember(&pendingset, i) == 1) printf("1");
            else if (sigismember(&pendingset, i) == 0) printf("0");
            else {
                perror("sigismember");
                exit(0);
            }
        }

        printf("\n");

        if (num == 5){
            // 解除阻塞
            sigprocmask(SIG_UNBLOCK, &set, NULL);
        }
    }

    return 0;
}
```

### `int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);`

```c++
/*

    #include <signal.h>
    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
        - 功能捕捉：检查或改变信号的处理，信号捕捉。
        - 参数：
            - signum:需要捕捉的信号的编号或者宏值（信号的名称），推荐宏值，移植性更强
            - act: 捕捉到信号之后相应的处理动作
            - oldact: 上一次对信号捕捉相关的设置，一般不使用，传递NULL
        - 返回值：
            - 成功：0
            - 失败：-1，设置errno

    
    struct sigaction {
        void     (*sa_handler)(int);    // 函数指针，指向的函数就是信号捕捉之后的处理函数
        void     (*sa_sigaction)(int, siginfo_t *, void *); // 不常用
        sigset_t   sa_mask;     // 设置的临时阻塞信号集，信号捕捉函数执行中临时设置某些信号阻塞。
        int        sa_flags;    //对捕捉到的信号选择一个信号处理函数，0为sa_handler，SA_SIGINFO为sa_sigaction
        void     (*sa_restorer)(void);  // 废弃
    };
*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

void my_handler(int num){
    printf("捕捉到信号%d...\n", num);
}

int main(int argc, char *argv[]){

    // 注册信号捕捉
    struct sigaction act;
    act.sa_flags = 0;   // 用sa_handler函数进行信号捕获处理
    act.sa_handler = my_handler;
    sigemptyset(&act.sa_mask);      // 清空临时阻塞信号集
    sigaction(SIGALRM, &act, NULL); // 信号集处理函数

    
    // 设置定时器
    struct itimerval new_value;
    // 周期性产生信号的时间
    new_value.it_interval.tv_sec = 3;
    new_value.it_interval.tv_usec = 0;
    // 延迟时间
    new_value.it_value.tv_sec = 2;
    new_value.it_value.tv_usec = 0;

    setitimer(ITIMER_REAL, &new_value, NULL);
    printf("定时器开始了\n");
    while(1);    
    return 0;
}
```

系统在执行信号处理函数时会临时的使用自定义数据集，等信号处理函数结束后系统将继续使用内核中的信号集。

信号处理函数在处理某一个信号时，当又有相同的信号发过来时，已经被置为0的未决信号再次被置为1，等当前的信号处理函数处理完后再执行到来的信号。

阻塞的常规信号是不支持等待队列的，因为信号的未决只能被置为1或0，而不知道来的信号有多少个。

### `SIGCHLD`信号

`SIGCHLD`信号产生的条件：

- 子进程终止时
- 子进程接收到`SIGSTOP`信号后暂停该进程
- 子进程处在停止态，接受`SIGCONT`后唤醒

以上三种情况都会给父进程发送`SIGCHLD`信号，父进程默认会忽略该信号。

```c++

// 使用SIGCHLD解决僵尸进程问题 

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/wait.h>
// 信号处理函数
void myhandler(int num){
    printf("捕捉到的信号...%d\n", num);

    // 回收子进程PCB的资源

    // while(1){
    //     wait(NULL); // 使用wait函数回收子进程资源，但是这样父进程就一直在信号处理函数中
    // }

    while(1){
        int ret = waitpid(-1, NULL, WNOHANG);   //使用waitpid函数的非阻塞模式
        if (ret > 0){
            printf("%d process die\n", ret);
        }else if (ret == 0){    // 如果还有子进程活着
            break;
        }else {     // 所有子进程都被回收
            break;
        }
    }
    
}

int main(int argc, char *argv[]){
    
    // 信号捕获前设置好阻塞信号集，阻塞SIGCHLD，因为可能子进程很快结束，父进程来不及注册完信号捕捉函数
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGCHLD);
    sigprocmask(SIG_BLOCK, &set, NULL);


    pid_t pid;

    // 创建20个子进程
    for (int i = 0; i < 20; i++){
        pid = fork();
        if (pid == 0) break;    // 子进程不再重新创建子进程
    }

        if (pid > 0){
            // 父进程
            // 捕捉子进程死亡时发送的SIGCHLD信号

            struct sigaction act;
            act.sa_flags = 0;
            sigemptyset(&act.sa_mask);  
            act.sa_handler = myhandler;
            sigaction(SIGCHLD, &act, NULL);     // 捕获信号后进行处理

            // 信号捕获后解除SIGCHLD信号阻塞
             sigprocmask(SIG_UNBLOCK, &set, NULL);


            while(1){
                printf("parent process...%d\n", getpid());
                sleep(2);
            }
        }else if (pid == 0){
            
            printf("child process...%d\n", getpid());
        }


    return 0;
}
```

当设置阻塞后，如果从开始注册信号到注册成功这段时间里，有n个`SIGCHID`信号产生的话，那么第一个产生的`SIGCHID`会抢先将未决位置为1，余下的n-1个`SIGCHID`被丢弃，然后当阻塞解除之后，信号处理函数发现这时候对应信号的未决位为1，继而执行函数处理该信号，处理函数中的while循环顺带将其他n-1子进程也一网打尽了，在这期间未决位的状态只经历了两次变化，即0->1->0。

