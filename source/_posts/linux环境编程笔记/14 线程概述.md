---
title: 14 线程概述
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 线程

## 一、概述

- 线程是允许应用程序并发执行多个任务一种机制。一个进程可以包含多个进程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括**初始化数据段**、**未初始化数据段**，以及**堆内存段**。（传统意义上的Unix进程只是多多线程程序的一个特例，该进程只包含一个线程）。

- 进程是CPU**分配资源**的最小单位，线程是操作系统**调度执行**的最小单位。

- 线程是轻量级的进程（`LWP`），在`linux`环境下线程的本质仍是进程。

- 查看指定进程的`LWP`号：

  ```shell
  ps -Lf pid
  ```

  

## 二、线程和进程的区别

- 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。
- 调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍需要复制诸如**内存页表和文件描述符表**之类的多种进程属性，这意味着fork()调用在时间上的开销仍然不菲。
- 线程之间能够方便、快速地共享信息。只需将数据复制到共享**全局变量或堆变量**中即可。
- 创建线程比创建进程通常要块10倍左右甚至更多。线程间是**共享虚拟地址空间**的，无需采用写时复制技术来复制内存，也无需复制页表。

## 三、线程之间共享和非共享的资源

### 3.1、共享资源：

进程ID和父进程ID

进程组ID和会话ID

文件描述符表

信号处置

文件系统的相关信息：文件权限掩码（`umask`）、当前工作目录

虚拟地址空间（除**栈**、**.text**）

### 3.2非共享资源：

线程ID

信号掩码

线程特有数据

error变量

实时调度策略和优先级

**栈**、**本地变量**和**函数的调用链**信息

## 四、线程相关操作函数

`int pthread_create(pthread_t *thread, const pthread_attr_t *attr, oid *(*start_routine) (void *), void *arg);`

```c++
/*

#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                    void *(*start_routine) (void *), void *arg);
    - 功能: 创建一个子线程
    - 参数:
        - pthread_t *thread: 传出参数，线程创建成功后，子线程线程ID被写道该变量中。1
        - attr: 需要设置的线程的属性，一般使用默认值，NULL  
        - start_routine: 函数指针，子线程需要处理的逻辑代码
        - arg: 第三个参数使用，传参
    - 返回值: 
        成功：0
        失败：返回错误号，该错误号errnum和之前的errno不一样。
            获取错误信息：调用 char* strerror(int errnum);
*/


#include <stdio.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
// 子线程执行函数
void * callback(void *arg){
    printf("child thread...\n");
    printf("num value:%d\n", *(int*)arg);
    return NULL;
}

int main(){

    pthread_t tid;
    int num = 10;

    // 创建一个子线程
    int ret = pthread_create(&tid, NULL, callback, (void*)&num);
    if (ret){
        char *errstr = strerror(ret);
        printf("%d:%s\n", ret, errstr);
    }

    for (int i = 0; i < 5; i++){
        printf("%d\n", i);
        sleep(1);
    }
    return 0;
}
```

`void pthread_exit(void *retval);`

`pthread_t pthread_self(void);`

`int pthread_equal(pthread_t t1, pthread_t t2);`

```c++
/*
    #include <pthread.h>
    void pthread_exit(void *retval);
        - 功能：终止一个线程，在哪个线程中调用就表示终止哪个线程
        - 参数：retval：需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到
    

    #include <pthread.h>
    pthread_t pthread_self(void);
        - 功能：获取当前线程的线ID


    #include <pthread.h>
    int pthread_equal(pthread_t t1, pthread_t t2);
        - 功能：比较两个线程ID是否相等
        不同操作系统, pthread_t类型实现方式不一样，有的是使用无符号长整形，有的是结构体实现的
    
*/

#include <pthread.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void *callback(void *arg){
    printf("child thread id: %ld\n", pthread_self());
    return NULL;    // 相当于调用了pthread_exit(NULL)
}

int main(int argc, char *argv[]){
    
    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, callback, NULL);
    if (ret){
        printf("%s\n", strerror(ret));
    }

    // 主线程
    for (int i = 0; i < 5; i++)
    printf("%d\n", i);
    // sleep(1);
    printf("tid : %ld, main thread id: %ld\n", tid, pthread_self());

    // 让主线程退出，主线程退出时不会影响其他正常运行的线程
    pthread_exit(NULL);
    // 线程退出后，后续的代码均不会执行。
    return 0;   //这行代码不会执行，进程不会退出
}
```

`int pthread_join(pthread_t thread, void **retval);`

```c++
/*

    #include <pthread.h>
    int pthread_join(pthread_t thread, void **retval);
        - 功能 : 和一个已经终止的线程进行连接。
        主要就是回收其他线程的资源，但一般来说就是父线程来回收子线程的资源，一般在主线程中使用。
        该函数是阻塞函数，该函数调用一次，只能回收一个子线程。
        - 参数 : 
            - thread : 需要回收的子线程的ID
            - retval : 接收子线程退出时的返回值
        - 返回值 : 
            - 成功 : 返回0
            - 失败 :  返回错误号errnum


*/
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>


void * callback(void * arg){
    printf("child thread id : %ld\n", pthread_self());
    char *str = "child exit..";     // str中保存常量"child exit.."的地址
    pthread_exit((void *)str);  //和return arg是一样的，都是线程结束传出的参数。
}

int main(int argc, char *argv[]){

    // 创建子线程
    pthread_t tid;
    pthread_create(&tid, NULL, callback, NULL);

    // 主线程
    for (int i = 0; i < 5; i++){
        printf("%d\n", i);
    }
    printf("tid:%ld, child thread id %ld\n", tid, pthread_self());

    // 主线程pthread_join()回收子线程的资源

    char *buf;  //定义字符串获取线程结束传出的参数
    pthread_join(tid, (void **)&buf);   // buf接受常量"child exit.."的地址
    printf("%s\n", (char *)(buf));
    
    // 让主线程退出，主线程退出时不会影响其他线程的运行
    pthread_exit(NULL);

    return 0;
}
```

`int pthread_detach(pthread_t thread);`

`detach()`的**作用是将子线程和主线程的关联分离**，也就是说detach()后子线程在后台独立继续运行，主线程无法再取得子线程的控制权**，**即使主线程结束，子线程未执行也不会结束。**当主线程结束时，由运行时库负责清理与子线程相关的资源。**

```c++
/*
    #include <pthread.h>
    int pthread_detach(pthread_t thread);
        - 功能：分离一个线程，被分离的线程在终止时，会自动释放资源给系统
            1、不能多次分离，会产生不可预料的行为
            2、不能去连接一个已经分离的线程，会报错。
        - 参数：需要分离的线程的ID
        - 返回值：
            成功：0
            失败：返回错误号errnum
*/

#include <pthread.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
	
	
void * callback(void * arg){
    printf("child thread id : %ld\n", pthread_self());
    return NULL;
}
	
int main(int argc, char *argv[]){
	
    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, callback, NULL);
    if (ret){
        char *s = strerror(ret);
        printf("error1 : %s\n", s);
    }
    
    // 打印出子线程和主线程的ID
    printf("tid: %ld, main thread id : %ld\n", tid, pthread_self());
	
    // 设置子线程分离,子线程分离后，子线程结束时对已经的资源就不需要主线程释放
    ret = pthread_detach(tid);
    if (ret){
        char *s = strerror(ret);
        printf("error2 : %s\n", s);
    }
    
	// 分离后再进行连接会报错的
    ret = pthread_join(tid, NULL);
    if (ret){
        char *s = strerror(ret);
        printf("error3 : %s\n", s);
    }
    
    pthread_exit(NULL);
    return 0;
}
```

![](/images/image/pthread_detach.png)



`int pthread_cancel(pthread_t thread);`

```c++
/*
    #include <pthread.h>
    int pthread_cancel(pthread_t thread);
        - 功能：取消线程（让该线程终止）
        取消某个线程，可以终止某个线程的执行，但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。
        取消点：当进行到系统规定好的一些系统调用时才会发生切换，可以粗略理解为从用户区到内核区的切换的这个时间点

*/
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void * callback(void * arg){

    printf("child thread id : %ld\n", pthread_self());
    for (int i = 0; i < 3; i++){
        printf("child %d\n", i);
        sleep(1);
    }
    
    return NULL;
}

int main(int argc, char *argv[]){

    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, callback, NULL);
    if (ret){
        char *s = strerror(ret);
        printf("error1 : %s\n", s);
    }
    
    printf("tid: %ld, main thread id : %ld\n", tid, pthread_self());

    // 取消线程
    ret = pthread_cancel(tid);
    if (ret){
        char *s = strerror(ret);
        printf("%s\n", s);
    }

     for (int i = 0; i < 3; i++){
        printf("%d\n", i);
        sleep(1);
    }

    pthread_exit(NULL);

    return 0;
}
```

![](/images/image/pthread_cancel.png)

线程取消后就不会显示接着显示`child i`后面的信息了

## 五、线程属性操作相关的函数



```c++
/*
    #include <pthread.h>

    int pthread_attr_init(pthread_attr_t *attr);
        - 初始化线程属性对象
    int pthread_attr_destroy(pthread_attr_t *attr);
        - 销毁线程属性对象

    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
        - 获取线程属性分离状态
    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
        - 设置线程属性分离状态

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>


void * callback(void * arg){

    printf("child thread id : %ld\n", pthread_self());
    return NULL;
}

int main(int argc, char *argv[]){

    // 创建一个线程属性变量
    pthread_attr_t attr;
    
    // 初始化线程属性变量
    pthread_attr_init(&attr);

    // 设置属性
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);


    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&tid, &attr, callback, NULL);
    if (ret){
        char *s = strerror(ret);
        printf("error1 : %s\n", s);
    }

    // 获取线程的栈的大小
    size_t  size;
    pthread_attr_getstacksize(&attr, &size);
    printf("stack size : %ld\n", size);
    
    printf("tid: %ld, main thread id : %ld\n", tid, pthread_self());

    // 线程分离
    pthread_detach(tid);

    // 释放线程属性资源
    pthread_attr_destroy(&attr);
    pthread_exit(NULL);

    return 0;
}
```

