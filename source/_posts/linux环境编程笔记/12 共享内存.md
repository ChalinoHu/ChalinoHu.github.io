---
title: 12 共享内存
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 共享内存

[toc]

## 一、概述

共享内存允许<u>两个或多个进程</u>共享物理内存的同一块区域（通常被成为**段**）。由于一个共享内存段会成为一个**进程空间**的一部分，因此这种`IPC`机制**无需内核介入**。所有需要做的就是让一个进程将数据复制进**共享内存**中，并且这部分数据会对其他**所有共享同一个段的进程**可用。

与**管道**要求发送进程将数据从**用户空间的缓冲区**复制到**内核内存**和接受进程将数据从**内核内存**复制到**用户空间缓冲区**的做法相比，这种`IPC`技术的速度更快。

## 二、使用共享内存的步骤

1、调用`shmget()`创建一个新共享内存段，或取得一个既有内存共享段的标识符(即由其他进程创建的共享内存段)。这个调用后将返回后续调用中需要用到的**共享内存标识符**。

2、使用`shmat()`来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。

3、此刻可向对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用`shmat()`的返回值`addr`，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。

4、调用`shmdt()`来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在<u>进程终止时会自动完成这一步</u>。

4、调用的`shmctl()`来删除共享内存段。只有当前<u>所有附加内存段的进程都与之分离之后</u>内存段才会销毁，只有一个进程需要执行这一步。

## 三、共享内存操作函数

### `int shmget(key_t key, size_t size, int shmflg);`

### `void *shmat(int shmid, const void *shmaddr, int shmflg);`

### `int shmdt(const void *shmaddr);`

### `int shmctl(int shmid, int cmd, struct shmid_ds *buf);`

```c++
/*
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);
    - 功能：创建一个新的共享内存段，或者获取一个既有共享内存段的标识。
            新创建共享内存段的数据都会被初始化为0。
    - 参数：
        - key：key_t类型是一个整形，通过这个找到或者创建一个共享内存。
                一般使用16进制值表示，非0值。
        - size：共享内存的大小。
        - shmlg：属性
        - 访问权限
        - 附加属性：创建/判断共享内存是不是存在
            - 创建：IPC_CREAT
            - 判断共享内存是否存在：IPC_EXCL，需要和IPC_CREAT一起使用
            IPC_CREAT | IPC_EXCL | 0664

    - 返回值：
        - 成功：返回共享内存的引用的指标ID
        - 失败：-1，设置errno




#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
    - 功能：和当前进程进行关联
    - 参数：
        - shmid：共享内存的标志ID，shmget()的返回值
        - shmaddr：申请的共享内存的起始地址，指定为NULL，由内核分配。
        - shmflg：对共享内存的操作
            - SHM_RDONLY, 必须要有读权限
            - 0 ：读写权限
    - 返回值：
        - 成功：返回共享内存的首地址
        - 失败：(void *) -1，设置errno

int shmdt(const void *shmaddr);
    - 功能：解除当前进程和共享内存的关联
    - 参数：
        - shmaddr：共享内存的首地址
    - 返回值：
        - 成功：0
        - 失败：-1， 设置errno


#include <sys/ipc.h>
#include <sys/shm.h>
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
    - 功能：删除共享内存，共享内存删除才会消失。创建共享内存的进程被销毁对共享内存没有影响。
    - 参数：
        - shmid：共享内存标志
        - cmd：要做的操作
            - IPC_STAT：获取共享内存的当前的状态
            - IPC_SET：设置共享内存的状态
            - IPC_RMID：标记共享内存被销毁
        - buf：需要设置或者获取的共享内存的属性信息
            cmd指令对buf的操作：
                - IPC_STAT：buf用来存储数据
                - IPC_SET：buf中需要初始化数据，然后设置到内核中
                -IPC_RMID：没有用，NULL
  
#include <sys/types.h>
#include <sys/ipc.h>
  key_t ftok(const char *pathname, int proj_id);
    - 功能：根据指定的路径名，和int值，生成一个共享内存的key
    - 参数：
        - pathname：指定一个存在的，可访问到的文件
        - proj_id：int类型的值但是这个系统调用只会使用且其中的一个字节(8个位)
            范围：0~255 一般指定一个字符，如'a'
    - 返回值：
        成功：key
        失败：-1，设置errno
*/
```

### 案例：共享内存读写数据

```c++
// 向共享内存写数据
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <string.h>

int main(int argc, char *argv[]){
    
    // 1、创建一个共享内存
    int shmid = shmget(100, 4096, IPC_CREAT | 0664);    

    // 2、和当前进程进行关联
    void* addr = shmat(shmid, NULL, 0);	// 内核分配内存

    // 3、读数据
    char *str = "nihaoshijie!";
    memcpy(addr, str, strlen(str) + 1);

    printf("按任意键继续...\n");
    getchar();      // 先等待其他进程解除共享内存的关联

    // 4、解除关联
    shmdt(addr);

    // 5、删除共享内存
    shmctl(shmid, IPC_RMID, NULL);
    return 0;
}
```

```c++
// 从共享内存读数据
#include <sys/ipc.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>

int main(int argc, char *argv[]){

    // 1、获取一个共享内存, shmget函数第一个参数key和想获取的共享内存的进程的key一致。
    //  第二个参数指定的内存大小不能大于4096
    int shmid = shmget(100, 4096, IPC_CREAT);

    // 2、和当前进程进行关联
    void* addr = shmat(shmid, NULL, 0);

    // 3、读数据
    printf("%s\n", (char *)addr);

    printf("按任意键继续...\n");
    getchar();
    // 4、解除关联
    shmdt(addr);

    // 5、删除共享内存
    shmctl(shmid, IPC_RMID, NULL);

    return 0;
}
```

## 四、关于共享内存的几个问题：

1、操作系统如何知道一块共享内存被几个进程关联？

 -  共享内存维护了一个结构体`struct shmid_ds`,这个结构体有一个成员`shm_nattach`记录了关联进程的个数。

2、可不可以对共享内存进行多次删除 `shmctl`

 - 可以的，因为`shmctl`标记删除共享内存，不是直接删除。当和进程关联的进程数为0时就被删除了

 - 当共享内存`key`为0时，表示共享内存被标记删除了。
    - 如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。

## 五、共享内存操作命令：

### `ipcs`用法：

```shell
ipcs -a			# 打印当前系统中所有的进程间通信方式的信息
```

```shell
ipcs -m			# 打印出使用共享内存进行进程间通信的信息
```

```shell
ipcs -q			# 打印出使用消息队列进行进程间通信的信息
```

```shell
ipcs -s			# 打印出使用信号进行进程间通信的信息
```

### `ipcrm`用法

```shell
ipcrm -M shemkey		# 移除使用shmkey创建的共享内存段
```

```shell
ipcrm -m shmid			# 移除用shmid标识的共享内存段，这里的移除都是标记删除
```

```shell
ipcrm -Q msgkey			# 移除用msqkey创建的消息队列
```

```shell
ipcrm -q msgid			# 移除用msgid标识的消息队列
```

```shell
ipcrm -S semkey			# 移除用semkey创建的信号
```

```shell
ipcrm -s semid			# 移除用semid标识的信号
```

## 六、共享内存和内存映射的区别

1、<u>共享内存</u>可以直接创建，<u>内存映射</u>需要<u>磁盘文件</u>（匿名映射除外）

2、**共享内存效率更高**

3、<u>共享内存</u>中所有进程操作的是**同一块内存**；<u>内存映射</u>中每个进程在自己的虚拟空间有一个**独立的内存**。

4、数据安全

 - **进程突然退出**时共享内存还存在，而内存映射在进程结束后就消失了。

  - **运行进程的电脑死机，宕机**了之后数据存储在共享内存中的数据就没有了，而内存映射区的数据由于<u>磁盘文件</u>还存在。

5、生命周期

	- 内存映射区：**进程退出**，内存映射区销毁。
 - 共享内存：进程退出，共享内存还在，**标记删除（所有关联的进程数为0），或者关机**。
   	- 如果一个进程退出，会自动和共享内存取消关联。
