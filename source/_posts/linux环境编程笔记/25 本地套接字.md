---
title: 25 本地套接字
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 本地套接字

> 本地套接字的作用：本地的进程间通信
>
> ​	有关系的进程间的通信
>
> ​	没有关系的进程间的通信
>
> 本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。

```c
// 本地套接字的通信流程 TCP

// 服务端
1、创建监听的socket套接字
    int lfd = socket(AF_UNIX, SOCK_STREAM, 0);

2、监听的套接字要绑定本地的套接字文件 -> server端
    struct sockaddr_un addr;
    // 绑定成功之后，指定的sun_path中的套接字文件会自动生成
    int ret = bind(lfd, (struct sockaddr*) &addr, sizeof addr);

3、监听是否有客户端连接进来了
    listen(lfd, 100);

4、等待并接受连接请求
    struct sockaddr_un cliaddr;
    int len = sizeof cliaddr;
    int cfd = accept(lfd, (struct sockaddr *) &cliaddr, &len);

5、通信
    接收数据: read/recv
    发送数据: write/send

6、关闭连接
    close();


// 客户端
1、创建监听的socket套接字
    int lfd = socket(AF_UNIX, SOCK_STREAM, 0);
2、监听的套接字要绑定本地的IP和接口
    struct sockaddr_un addr;
    // 绑定成功之后，指定的sun_path中的套接字文件会自动生成
    int ret = bind(lfd, (struct sockaddr*) &addr, sizeof addr);
3、连接服务器
    struct sockaddr_un serveraddr;
	connect(fd, &serveraddr, sizeof serveraddr);
4、通信
    接收数据: read/recv
    发送数据: write/send
5、关闭连接
    close()
```

```c

#include <stdio.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/un.h>

int main(){
	//删除之前生成的伪文件
    unlink("server.sock");
    
// 1、创建监听的socket套接字
    int lfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (lfd == -1){
        perror("socket");
        exit(-1);
    }

// 2、监听的套接字要绑定本地的套接字文件 -> server端
    struct sockaddr_un addr;
    addr.sun_family = AF_LOCAL;
    strcpy(addr.sun_path, "server.sock");
    // 绑定成功之后，指定的sun_path中的套接字文件会自动生成
    int ret = bind(lfd, (struct sockaddr*) &addr, sizeof addr);

// 3、监听是否有客户端连接进来了
    ret = listen(lfd, 100);
    if (ret == -1){
        perror("listen");
        exit(-1);
    }

// 4、等待并接受连接请求
    struct sockaddr_un cliaddr;
    int len = sizeof cliaddr;
    int cfd = accept(lfd, (struct sockaddr *) &cliaddr, &len);
    if (cfd == -1){
        perror("accept");
        exit(-1);
    }

    printf("client socket filename : %s\n", cliaddr.sun_path);

// 5、通信
    while(1){
        char buf[128];
        // 读数据
        int len = recv(cfd, buf, sizeof buf, 0);
        if (len == -1){
            perror("recv");
            exit(-1);
        }else if(len == 0){
            printf("client closed..\n");
            break;
        }else {
            printf("client say : %s\n", buf);
            send(cfd, buf, strlen(buf), 0);
        }

    }

// 6、关闭连接
    close(cfd);
    close(cfd);
    
    return 0;
}
```

```c

#include <stdio.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/un.h>

int main(){
    // 删除之气那生成的伪文件
    unlink("client.sock");

// 1、创建套接字
    int fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (fd == -1){
        perror("socket");
        exit(-1);
    }

// 2、监听的套接字要绑定本地的套接字文件 -> server端
    struct sockaddr_un addr;
    // 绑定成功之后，指定的sun_path中的套接字文件会自动生成
    addr.sun_family = AF_LOCAL;
    strcpy(addr.sun_path, "client.sock");
    int ret = bind(fd, (struct sockaddr*) &addr, sizeof addr);
    if(ret == -1){
        perror("bind");
        exit(-1);
    }

// 3、连接服务器
    struct sockaddr_un saddr;
    strcpy(saddr.sun_path, "server.sock");
    saddr.sun_family = AF_LOCAL;
    ret = connect(fd, (struct sockaddr*)&saddr, sizeof saddr);
    if (ret == -1){
        perror("connect");
        exit(-1);
    }
    
// 4、通信
    while (1){
        static int num = 0;
        char buf[128];

        // 发数据
        sprintf(buf, "hello, I am client %d..\n", num++);

        send(fd, buf, strlen(buf), 0);

        printf("client say: %s\n", buf);

        // 读数据
        int len = recv(fd, buf, sizeof buf, 0);
        if (len == -1){
            perror("recv");
            exit(-1);
        }else if(len == 0){
            printf("server closed..\n");
            break;
        }else {
            printf("server say : %s\n", buf);
        }

        sleep(1);
    }

// 5、关闭连接
    close(fd);
    return 0;
}
```

