---
title: 18 三次握手和四次挥手
date: 2022-05-27 21:02:46
tags: linux环境编程
---



# 三次握手





<img src="/images/image/TCP三次握手.png" style="zoom:60%;" />

```c
第一次握手：
    1、客户端发起连接请求：SYN=1，报文中是不能携带数据的
    2、生成一个随机的32位序号seq=J，该序号后面可以携带数据（数据大小）
第二次握手：
    1、服务器接受客户端的请求：ACK=1
    2、服务器回发确认序号：ack=客户端序号J+数据长度+SYN/FIN（按一个字节算）
    3、服务端向客户端发起连接请求：SYN=1
    4、服务端生成随机序号：seq=K
第三次握手：
    1、客户端答应客户端的请求：ACK=1，此时发送的报文中可以携带通信数据了
    2、客户端回发确认序号：ack=服务端序号K+数据长度+SYN/FIn（按一个字节算）
```

```c
TCP需要三次的原因主要是让客户端和服务端都确保双方发送数据和接收数据没问题。
第一次握手：
    客户端向服务端发送消息，此时客户端知道自己可以发数据，服务端收到客户端的消息也知道了客户端可以发数据，自己可以接收数据
第二次握手：
    服务端向客户端发送消息，此时服务端知道自己可以发送数据，并且客户端也知道服务端可以发送数据。不过服务端不知道客户端是否能够接收数据
第三次握手：
    客户端向服务端发送数据，服务端知道了客户端可以接收数据，至此客户端和服务端都知道了自己和对方都具备发送消息的和接收消息的能力。
```

函数调用层面的三次握手： 

客户端调用`connect`()的时候，就是发一个SYN。

服务端`accept()`的时候，实际上是从内核的`accept`队列里面取一个连接，如果这个队列为空，则进程阻塞（阻塞模式下）。如果`accept()`返回则说明成功取到一个连接，返回到应用层。

大致的过程是客户端发一个syn之后，服务端将这个连接放入到backlog队列，在收到客户端的ack之后将这个请求移到accept队列。所以`accept()`一定是发生在三次握手之后，`connect()`只是发一个syn而已。

额，Accept根本不参与三次握手，服务器只要Listen，客户端`connect()`是与服务器内核握手，`connect()`完成之后，服务器都不需要写`Accept()`，客户端就已经可以发送数据了，你完全可以让这批数据在服务器里躺一年之后，再`Accept()`。

第一次握手：客户端发送syn包(syn=j)到服务器。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个ASK包（ask=k）。
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)。
三次握手完成后，客户端和服务器就建立了tcp连接。这时可以调用accept函数获得此连接。

# 四次挥手

四次挥手发生在断开连接的时候，在程序中调用了`close()`会使用TCP协议进行四次挥手。

客户端和服务端都可以主动发起断开连接，谁先调用`close()`谁就是发起者。

因为在TCP连接时，次啊用三次握手建立的连接时双向的，因此在四次挥手阶段也需要双向断开。
