---
title: 09 管道和有名管道
date: 2022-05-27 21:02:46
tags: linux环境编程
---



[TOC]

## 1、匿名管道

### 1.1、管道简介

管道也叫无名（匿名）管道，它时`unix`系统中进程间通信（`IPC`）最古老的通信方式，所有`unix`系统都支持这种通信机制。

例：

统计一个目录中文件的个数命令：`ls | wc -l`,为了执行该命令shell创建了两个进程来分别执行`ls`和`wc`。

![](/images/image/pip.png)

### 1.2、管道的特点：

- 管道其实是在**内核内存**中维护缓冲器，这个缓冲器的存储能力是有限的，不同操作系统的大小是不一定的。

- 管道拥有文件的特质：读操作、写操作，<u>匿名管道没有文件实体，有名管道有文件实体</u>，但不存储数据。可以按照操作文件的方式对管道进行操作。

- 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。

- 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。

- 在管道中的数据的传递方向是单向的，一段用于写入，一段用于读取，管道是半双工的。

- 从管道读数据是**一次性操作**，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用`lseek()`随机的访问数据。

- 匿名管道只能在具有公共祖先的进程（父子进程，兄弟进程，或其它具有亲缘关系的进程）之间使用。

  ![](/images/image/pip2.png)

亲戚进程之间能使用管道主要是这些进程之间被fork之后虚拟地址空间是从父进程变化而来的，它们共享文件描述符的。

**匿名管道的数据结构：环形队列**

### 1.3、匿名管道的使用：

```c++
/*
    #include <unistd.h>
    int pipe(int pipefd[2]);
        功能：创建一个匿名管道来进行进程间通信
        参数：int pipefd[2],是一个传出参数，里面存的对应管道读写的两个文件描述符。
            - pipefd[0] 管道的读端
            - pipefd[1] 管道的写端
        返回值：
            - 成功：返回0
            - 失败：返回 -1，并且设置错误号errno 
    
    注意：匿名管道只能用于具有亲戚关系的进程之间进行通信（父子进程，兄弟进程）
    管道默认是阻塞的，如果管道没有，数据，read阻塞；如果管道满了，write阻塞。
*/


// 子进程给父进程发送数据，父进程读取数据
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]){

    // 在fork之前创建管道
    int pipefd[2];
    int ret = pipe(pipefd);
    if (ret == -1){
        perror("pipe");
        exit(0);
    }

    // 创建子进程
    pid_t pid = fork();

    if (pid > 0){   // 父进程
        
        printf("I am parent, pid:%d\n", getpid());

        while(1){
        // 读数据
        char buf[1024] = {0};

        int len = read(pipefd[0], buf, sizeof(buf));
        printf("parent rcve: %s, pid: %d\n", buf, getpid());
        sleep(1);
        // 写数据
        
        char *str = "hello, I am parent!";
        write(pipefd[1], str, strlen(str));
        sleep(1);
        }
        
    }else if (pid == 0){    // 子进程
        
        printf("I am child, pid:%d\n", getpid());

        while(1){
            // 写数据
            char *str  = "hello, I am child!";
            write(pipefd[1], str, strlen(str));     
            sleep(1);
            // 读数据
            char buf[1024] = {0};
            read(pipefd[0], buf, sizeof(buf));
            printf("child recv: %s, pid : %d\n", buf, getpid());
            sleep(1);    
        }


    }else {
        // 创建进程失败
        perror("fork");
        exit(0);
    }

    return 0;
}
```

![](/images/image/pip3.png)

### 1.4、查看缓冲区大小：

```shell
ulimit -a
```

![](/images/image/pip4.png)

`pip size`为8是指8个块，每个块有512字节。



### 1.5、查看缓冲大小的函数：`fpathconf`

```c++
#include <unistd.h>
#include <stdio.h>

int main(int argc, char *argv[]){
    int pipefd[2];
    int ret = pipe(pipefd);

    long size = fpathconf(pipefd[0], _PC_PIPE_BUF);
    printf("pipe size: %ld\n", size);
    return 0;
}
```

![](/images/image/pip5.png)

### 1.6、管道读写案例，模拟`ps aux | grep xxx`

```c++
/*
功能: 实现 ps aux | grep xxx   父子进程之间的通信

子进程: ps aux, 子进程结束后将数据发送给父进程
父进程: 获取数据

需要用到的相关函数：
    管道：pipe()
    子进程实现ps aux功能，execlp()
    子进程将数据从标准输出stdout_fileno 重定向到管道的写端, dup2()

*/

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(int argc, char *argv[]){

    // 创建管道
    int pipefd[2];
    int ret = pipe(pipefd);
    if (ret == -1){
        perror("pipe");
        exit(0);
    }

    // 创建子进程
    pid_t pid = fork();
    if (pid > 0){   //父进程

        // 关闭写端
        close(pipefd[1]);

        // 读数据
        char buf[1024] = {0};
        size_t len = -1;
    	
        // 循环读取管道的数据
        while((len = read(pipefd[0], buf, sizeof(buf) - 1)) > 0){
            printf("%s", buf);
            memset(buf, 0, 1024);
        }
    

        // 将读取的内容输出
    
    }else if (pid == 0){    // 子进程

        // 关闭读端
        close(pipefd[0]);

        // 将标准输出重定向到管道的写端
        dup2(pipefd[1], STDOUT_FILENO);

        // 执行 ps aux 功能
        execlp("ps", "ps", "aux", NULL);
        //写数据

    }else{
        perror("fork");
        exit(0);
    }

    return 0;
}
```

### 1.7、管道的读写特点：

使用管道需要注意的几点情况（默认是阻塞状态）：

1、所有指向管道写端的文件描述符都关闭了，即管道写端引用计数为0，那么如果有进程从管道中读取数据，管道中剩余的数据读完之后，之后调用read读数据会返回0，就像读到文件末尾一样。

2、如果指向管道写端的文件描述符没有全部关闭，即管道写端引用计数大于0，那么从管道中读数据的进程在读完管道中剩余数据后，再次调用read会阻塞，直到管道中有新的数据被写入，此时read读管道中的数据并返回读到数据的长度。

3、如果所有指向管道读端的文件描述符全都关闭了，即管道读端的引用计数为0，若此时有进程向管道中写数据，该进程会收到信号`SIGPIPE`，通常会导致进程异常终止。

4、如果有指向管道读端的文件描述符（管道读端的引用计数大于0），此时有进程管道中写数据，当管道中的数据写满后，再次write会导致阻塞，直到管道中数据被读出，有空位之后再接着写数据。

```markdown
总结：	
读管道：
	管道中有数据：read返回实际读到的字节数
	管道中无数据：
        管道写端所有的文件描述符全部关闭：read返回0，相当于读到文件末尾。
        管道写段文件描述符并没有全部关闭：read阻塞。
写管道：
	管道读端文件描述符全部关闭，进程接受到SIGPIPE信号，从而导致进程异常终止。
	管道读端文件描述符没有全部关闭：
		管道已满，write阻塞。
		管道未满，write将数据写入，并返回实际写入的字节数。
```

### 1.8、设置管道非阻塞

设置管道的非阻塞主要是设置管道读端和写端对应的文件描述符为非阻塞，其中主要依靠`fcntl()`的系统调用来进行设置的。

```c++
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <stdlib.h>

int main(int argc, char *argv[]){

    // 创建管道
    int pipefd[2];
    if (pipe(pipefd) == -1){
        perror("pipe");
        exit(0);
    }

    // 创建进程
    pid_t pid = fork();

    if (pid > 0){   //父进程读数据
        // 关闭管道写端
        close(pipefd[1]);

        // 将读端文件描述符更改为非阻塞
        int flags = fcntl(pipefd[0], F_GETFL);
        fcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK);

        // 循环读取管道内容
        while(1){
            char buf[1024] = {0};
            int len = -1;
            read(pipefd[0], buf, sizeof(buf));
            printf("parent recv: %s, %d\n", buf, getpid());
            sleep(2);
        }

    }else if (pid == 0){    // 子进程写数据

        // 关闭管道读端
        close(pipefd[0]);
        while (1)
        {
            char *str = "hello, world!";
            write(pipefd[1], str, strlen(str));
            sleep(10);        
        }

    }else {
        perror("fork");
        exit(0);
    }

    return 0;
}
```

![](/images/image/pip6.png)

## 2、有名管道

### 2.1、有名管道的概述

匿名管道由于没有名字，只能进行具有亲缘关系的进程中进行通信，为了实现任意进程之间的通信，提出了有名管道(FIFO)、也叫命名管道，FIFO文件。

有名管道(FIFO)比起匿名管道，提供了一个与路径名相关联的文件实体，以FIFO的文件形式存在于文件文件系统中。其打开方式与普通文件是一样的，这样即使某个进程与创建FIFO的进程不具备亲缘关系，只要访问该路径，就能彼此通过FIFO进行通信，因此通过FIFO不相关的进程也能交换数据。

​	1）有名管道fifo在多进程间通信是不需要有血缘关系的，和pipe无名管道不一样。但是原理都是**在内核空间中创建相应的内核缓冲区buf**。
​	2）FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来**标识内核中一条通道**。**各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信**。

一旦打开了FIFO，就能使用和管道及其他文件的系统调用一样的IO系统调用（如read()、write()、close()）。与管道一样，FIFO也有一个写入端和一个读入端，并且从有名管道中读取数据的顺序和写入顺序一致。FIFO的名称也由此而来：先进先出。

有名管道和匿名管道有一些特点是相同的，不一样的地方在于：

1、FIFO 在文件系统中作为一个特殊文件存在，但FIFO中的内容却放在内存中。

2、当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。

3、FIFO有名字，不相关的进程可以打开有名管道进行通信。

### 2.2 、有名管道的使用

1、通过命令创建有名管道文件

```shell
mkfifo 名字
```

2、通过函数创建有名管道文件

```c++
/*
    #include <sys/types.h>
    #include <sys/stat.h>

    int mkfifo(const char *pathname, mode_t mode);   
        功能：创建FIFO文件
        参数：
            -pathname:管道名称的路径
            -mode:文件的权限，和open一样，是一个八进制的数
        返回值：
            -成功返回0;
            -失败返回-1，设置errno;
*/

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){

    int ret = mkfifo("pfifo", 0664);
    if (ret == -1){
        perror("mkfifo");
        exit(0);
    }   
    return 0;
}
```

### 2.3、写进程给有名管道写数据，读进程从有名管道读数据  

写进程（`write.c`）

```c++
// 向管道中写数据

#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>

int main(){

    // 判断有名管道文件是否存在，不存在创建有名管道文件

    if (access("test", W_OK) == -1){

        printf("有名管道文件不存在,创建有名管道\n");

        if (mkfifo("test", 0664) == -1){
            perror("mkfifo");
            exit(0);
        }
    }

    // 打开又名管道文件
    int fd = open("test", O_WRONLY);
    if (fd < 0){
        perror("open");
        exit(0);
    }else{
        // 写文件
        for (int i = 0; i < 100; i++){
            char buf[1024] = {0};
            sprintf(buf, "hello:%d", i);
            write(fd,buf,strlen(buf));
            sleep(1);
        }
        
    }

    close(fd);

    return 0;
}
```

读进程(`read.c`)

```c++
// 从管道中读数据
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>

int main(){

    // 打开有名管道文件
    int fd = open("test", O_RDONLY);
    if (fd < 0){
        perror("open");
        exit(0);
    }

    // 读文件
    while(1){
        char buf[1024] = {0};
        int len = read(fd, buf, sizeof(buf));
        if (len == 0){	// 没有写端文件描述符的引用，返回0表示写端断开了
            printf("写端断开了\n");
            break;
        }
        printf("recv : %s\n", buf);
    }
    return 0;
}
```

![](/images/image/fifo1.png)

### 2.4、有名管道使用注意事项

1、如果一个只读进程打开管道会被阻塞，直到另外一个只写进程打开管道

2、如果一个只写进程打开管道会被阻塞，直到另外一个只读进程打开管道

```c++
读管道：
	管道中有数据，read返回实际读到的字节数。
	管道中无数据：
		管道写端全部关闭，read返回0，相当于读到了文件末尾。
		写端没有全部关闭，读端阻塞等待。
写管道：
	管道读端被全部关闭，进程异常终止（收到一个SIGPIPEs）。
	管道读端没有被全部关闭：
		管道已经被写满了：write会zuse。
		管道没有被写满：write将数据写入，并返回实际写入的字节数。
```

### 2.5、 案例，两个进程通过有名管道进行聊天

`chartA.c`

```c++
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>

int main(){

    // 查看管道文件是否存在
    if (access("fifo1", F_OK) < 0){
        printf("没有管道文件，创建有名管道文件\n");
        
        if (mkfifo("fifo1", 0664) < 0){
            perror("mkfifo");
            exit(0);
        }
    }

    if (access("fifo2", F_OK) < 0){
        printf("没有管道文件，创建有名管道文件\n");
        
        if (mkfifo("fifo2", 0664) < 0){
            perror("mkfifo");
            exit(0);
        }
    }

    // 打开有名管道文件
    int fdw, fdr;
    if ((fdw = open("fifo1",O_WRONLY)) < 0){
        perror("open");
        exit(0);
    }
    printf("打开fifo1成功，准备写数据...\n");

    if ((fdr = open("fifo2",O_RDONLY)) < 0){
        perror("open");
        exit(0);
    }
    printf("打开fifo2成功，准备读数据...\n");

    // 循环写读数据
    char buf[128];
    while(1){
        // 从终端获取发送的消息
        memset(buf, 0, 128);
        fgets(buf, 128, stdin);
        // 写数据
        write(fdw, buf, strlen(buf));
        

        // 读数据
        memset(buf, 0, 128);
        if (read(fdr, buf, 128)){
            printf("rec : %s\n", buf);
            
        }
    }

    close(fdw);
    close(fdr);
    return 0;
}
```

`chartB.c`

```c++
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>

int main(){

    // 查看管道文件是否存在
    if (access("fifo1", F_OK) < 0){
        printf("没有管道文件，创建有名管道文件\n");
        
        if (mkfifo("fifo1", 0664) < 0){
            perror("mkfifo");
            exit(0);
        }
    }

    if (access("fifo2", F_OK) < 0){
        printf("没有管道文件，创建有名管道文件\n");
        
        if (mkfifo("fifo2", 0664) < 0){
            perror("mkfifo");
            exit(0);
        }
    }

    // 打开有名管道文件
    int fdw, fdr;
    
    if ((fdr = open("fifo1",O_RDONLY)) < 0){
        perror("open");
        exit(0);
    }
    printf("打开fifo1成功，准备读数据...\n");

    if ((fdw = open("fifo2",O_WRONLY)) < 0){
        perror("open");
        exit(0);
    }
    printf("打开fifo2成功，准备写数据...\n");



    // 循环读写数据
    char buf[128];
    while(1){

        // 读数据
        memset(buf, 0, 128);
        if (read(fdr, buf, sizeof buf)){
            printf("rec : %s", buf);
            
        }

        // 从终端获取发送的消息
        memset(buf, 0, 128);
        fgets(buf, 128, stdin);

        // 写数据
        if(write(fdw, buf, strlen(buf)) < 0){
            perror("write");
        }
        
    }

    close(fdr);
    close(fdw);
    return 0;
}
```

