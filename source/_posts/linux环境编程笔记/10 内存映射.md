---
title: 10 内存映射
date: 2022-05-27 21:02:46
tags: linux环境编程
---

# 内存映射

[TOC]

## 1、概述

内存映射(Memory-mapped I/O)是将**磁盘文件**的数据映射到**内存**，用户**通过修改内存就能修改磁盘文件**，非阻塞。

![](/images/image/mem.png)

多个进程的进程虚拟地址空间映射同一个文件，通过对该文件的写入和读取就能实现进程间的通信。

## 2、内存映射函数的使用

```c++
/*
    #include <sys/mman.h>

    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
        功能：映射一个文件或设备的数据到内存中
        参数：
            - addr：映射到内存的地址，NULL，由内核指定。
            - length：要映射的数据的长度，这个值必须大于0，建议直接使用文件的长度。
                获取文件的长度：stat 或者 lseek
            - prot:
                PROT_EXEC:执行权限  PROT_READ:读权限  PROT_WRITE:写权限 PROT_NONE:无权限
                要映射内存，必须要有读的权限
            - flags:
                MAP_SHARED : 映射区的数据自动与磁盘文件进行同步，若要完成进程间通信，必须要设置该选项
                MAP_PRIVATE : 不同步，内存映射区中的数据改变了，对原来的数据不会改变，会创建一个新的文件(copy on write)
            - fd: 需要映射文件的文件描述符
                - 通过open得到，open的是一个磁盘文件
                注意:文件的大小要大于0;open的权限不能和prot的权限出现冲突
                若PROT的权限是PROT_READ,open的权限可以为只读，或者读写；
                若PROT的权限是PROT_READ | PROT_WRITE, open的权限为读写
                （小总结：PROT必须要有读的权限，PROT的权限要小于等于open的权限）
            - offset: 偏移量，一般不用。必须指定的是4K的整数倍。0表示不偏移，表示从文件的开头进行
        返回值：成功:返回内存中映射的地址。
               失败:返回MAP_FAILED((void *) -1)，并且设置errno。

    int munmap(void *addr, size_t length);
        功能:释放内存映射
        参数：
            - addr : 要释放的内存的地址
            - length : 要释放内存的大小，和mmap中length的长度一致
*/


/*

    使用内存映射实现进程间通信：
    1、 有关系的进程（父子进程）：还没有子进程的时候，
        通过唯一的父进程创建内存映射区，之后再创建子进程，
        这样父子进程之间就能共享创建的内存映射区。

    2、 没有关系的进程：准备一个大小不为0的磁盘文件。
        进程1 通过磁盘文件创建内存映射区，并得到一个操作这块内存的指针。
        进程2 通过相同的文件创建内存映射区，并得到一个和进程1相同的操作这块内存的指针。
        进程1和进程2使用内存映射区通信。
    
    注意：内存映射区是非阻塞的。
*/

#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

int main(int argc, char *argv[]){

    // 1、打开一个文件
    int fd = open("test.txt", O_RDWR);
    if (fd < 0){
        perror("open");
        exit(0);
    }

    int size = lseek(fd, 0, SEEK_END);

    // 2、创建内存映射区
    void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (ptr == MAP_FAILED){
        perror("mmap");
        exit(0);
    }

    // 3、创建子进程
    pid_t pid = fork();
    if (pid > 0){      // 父进程
        // 从内存映射中读取数据
        wait(NULL);
        char buf[64] = {0};
        strcpy(buf, (char *)ptr);
        printf("data : %s\n", buf);           

        
    }else if (pid == 0){    // 子进程
        // 往内存映射区中写数据
    strcpy((char *)ptr, "nihao");
    }else {
        perror("fork");
        exit(0);
    }

    // 4、释放内存映射区内存
    int ret = munmap(ptr, size);
    if (ret < 0){
        perror("munmap");
        exit(0);
    }

    return 0;
}
```

## 3、内存映射的注意事项

**（1）、如果对mmap的返回值(ptr)做++操作(ptr++)，munmap是否能成功？**

​	（void *）是可以进行++操作的，但不建议这样做，因为这样可能会造成munmap释放内存不正确。

**（2）、如果调用open函数给与的权限是O_RDONLY，mmap时prot参数指定PROT_READ | PROT_WRITE会怎么样？**

​	会发生错误，返回MAP_FAILED，建议open函数中权限建议和prot参数的权限保持一致。

**（3）、如果文件偏移量为1000会怎么样？**

​	偏移量只能是`4K`的整数倍，偏移1000会返回MAP_FAILED

**（4）、mmap什么情况下会调用失败？**

 -  第二个参数：`length = 0`

 - 第三个参数：prot

   - 只给了写权限

     prot权限大于第5个参数fd，通过open打开是所给的权限

**（5）、可以open的时候O_CREAT一个新文件来创建映射区吗？**

		- 可以，但如果创建文件的大小为0肯定不行。
		- 可以对新文件进行拓展，使用`lseek()`或者`truncate()`

**（6）、`mmap`后关闭文件描述符`fd`，对文件映射会有影响吗？**

​	`fd`关闭后，`fd`创建的内存映射区还是存在的，创建内存映射区之后关闭`fd`对内存映射区没有影响。

（7）、对ptr越界操作会怎么样？

越界操作操作的是非法内存，这样会造成**段错误**。

## 4、内存映射实现文件复制

```c++
/*
    使用内存映射实现文件拷贝的功能
    思路：
        1、对原始的文件进行内存映射
        2、创建一个新文件（拓展该文件）
        3、将新文件的数据映射到内存中
        4、通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中
        5、释放资源
*/

#include <unistd.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

int main(int argc, char *argv[]){

    // 1、对原始文件进行内存映射
    int fd = open("source.txt", O_RDWR);
    if (fd == -1){
        perror("open");
        exit(0);
    }
    // 获取原始文件的大小
    off_t len = lseek(fd, 0, SEEK_END);

    // 2、创建一个新文件并拓展该文件
    int fd1 = open("cpy.txt", O_RDWR | O_CREAT, 0664);
    if (fd1 == -1){
         perror("open an creat");
    }
    if (truncate("cpy.txt", len) < 0){
        perror("truncate");
        exit(0);
    }    
    // 执行一个写操作让拓展生效
    if (write(fd1, " ", 1) < 0){
        perror("write");
        exit(0);
    } 

     // 3、分别做内存映射
    void* ptr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED,fd, 0);
    void* ptr1 = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED,fd1, 0);
    
    if (ptr == MAP_FAILED || ptr1 == MAP_FAILED){
        perror("mmap");
        exit(0);
    }

    // 内存拷贝
    memcpy(ptr1, ptr, len);

    // 释放资源
    // 先打开的后释放，后打开的先释放
    munmap(ptr1, len);
    munmap(ptr, len);

    close(fd1);
    close(fd);

    return 0;
}
```

## 5、匿名映射

不需要文件实体进行内存映射

```c++
/*
匿名映射
*/

#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

int main(int argc, char *argv[]){
    
    // 1、创建匿名内存映射区
    int len = 4096; // 匿名文件的长度
    void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (ptr == MAP_FAILED){
        perror("mmap");
        exit(0);
    }

    //  2、父子进程间通信
    pid_t pid = fork();
    if (pid > 0){   // 父进程
        strcpy((char *)ptr, "nihao,shijie!");
        wait(NULL);
    }else if (pid == 0){    // 子进程
        sleep(3);
        printf("%s\n", (char *)ptr);
    }else {
        perror("fork");
        exit(0);
    }

    if (munmap(ptr, len) == -1 ){
        perror("munmap");
        exit(0);
    }
    
    return 0;
}
```

![](/images/image/nonamemmap.png)

