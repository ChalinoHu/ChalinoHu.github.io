---
title: 智能指针
tags: c++基础
---



## 一、std::auto_ptr

### 1、auto_ptr的基本用法

```c++
#include <memory>

int main()
{
    //初始化
    std::auto_ptr<int> sp1(new int(8));
    
    //reset初始化
    std::auto_ptr<int> sp2;
    sp2.reset(new int(8));
    
    // 利用其他只能指针对象初始化
    auto_ptr<int> sp5;
	auto_ptr<int> sp6 = sp5;

    return 0;
}
```

智能指针对象 **sp1** 和 **sp2** 均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在 **sp1** 和 **sp2** 释放时得到释放。

### 2、缺点

当复制一个 **std::auto_ptr** 对象时（拷贝复制或 operator = 复制），原对象所持有的堆内存对象也会转移给复制出来的对象。

```c++
#include <memory>
using namespace std;

int main(){
	
	auto_ptr<int> sp1(new int(8));
	auto_ptr<int> sp2(sp1);
	// sp1 is NULL, sp2 is initialized by sp1

	auto_ptr<int> sp3(new int(8));
	auto_ptr<int> sp4;
	sp4 = sp3;
	// sp3 is NULL, sp4 is initialized by sp3
	
	return 0;
}
```

sp1 持有的堆对象被转移给 sp2（sp2被置为NULL），sp3 持有的堆对象被转移给 sp4（sp3被置为NULL）。

当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误。

## 二、std::unique_ptr

### 1、初始化

**std::unique_ptr** 对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是 1，**std::unique_ptr** 对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个 **std::unique_ptr** 对象：

```c++
#include <memory>
using namespace std;

int main(){
	// 初始化方式1
	unique_ptr<int> sp1(new int(8));
	
	// 初始化方式2
	unique_ptr<int> sp2;
	sp2.reset(new int(8));
	
	// 初始化方式3
	unique_ptr<int> sp3 = make_unique<int>(8);	// c++14引入
	return 0;
}
```

鉴于`std::auto_ptr`的前车之鉴，`std::unique_ptr`禁止复制语义，为了达到这个效果，**std::unique_ptr** 类的拷贝构造函数和赋值运算符（operator =）被标记为 **delete**。

```c++
template <class T>
class unique_ptr
{
    //省略其他代码...

    //拷贝构造函数和赋值运算符被标记为delete
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
};
```

因此下列代码是无法编译通过的：

```c++
std::unique_ptr<int> sp1(std::make_unique<int>(123));;

//以下代码无法通过编译
//std::unique_ptr<int> sp2(sp1);
std::unique_ptr<int> sp3;
//以下代码无法通过编译
//sp3 = sp1;
```

禁止复制语义也存在特例，即可以通过一个函数返回一个 `std::unique_ptr`：

```c++
#include <memory>
using namespace std;

unique_ptr<int> func(int val){
	unique_ptr<int> p(new int(val));
	return p;
}

int main(){
	
	unique_ptr<int> p = func(8);
	return 0;
}
```

实现以上赋值是因为`unique_ptr`的移动构造函数和移动赋值函数：

```c++
#include <memory>

int main()
{
    std::unique_ptr<int> sp1(std::make_unique<int>(123));

    std::unique_ptr<int> sp2(std::move(sp1));

    std::unique_ptr<int> sp3;
    sp3 = std::move(sp2);

    return 0;
}
```

以上代码利用 std::move 将 sp1 持有的堆内存（值为 123）转移给 sp2，再把 sp2 转移给 sp3。最后，sp1 和 sp2 不再持有堆内存的引用，变成一个空的智能指针对象。

并不是所有的对象的 std::move 操作都有意义，只有实现了移动构造函数（Move Constructor）或移动赋值运算符（operator =）的类才行，而 **std::unique_ptr** 正好实现了这二者，以下是实现伪码：

```c++
template<typename T, typename Deletor>
class MyUniquePtr{
public:
	
	// other function...
	
	MyUniquePtr(MyUniquePtr&& rhs):m_ptr(rhs.m_ptr){
		rhs.m_ptr = NULL;
	}
	MyUniquePtr& operator=(MyUniquePtr&& rhs){
		m_ptr = rhs.m_ptr;
		rhs.m_ptr = NULL;
		return *this;
	}
private:
	T* m_ptr;
};
```

**std::unique_ptr** 不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下：

```c++
	unique_ptr<int[]> sp1(new int[10]);
	
	unique_ptr<int[]> sp2;
	sp2.reset(new int[10]);
	
	unique_ptr<int[]> sp3 = make_unique<int[]>(10);
```



### 2、自定义智能指针对象持有的资源的释放函数

​	默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete 或者 delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个 Socket 类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以 **std::unique_ptr** 为例：

```c++
#include <iostream>
#include <memry>
using namespace std;

class Socket{
public:
	Socket(){}
	~Socket(){}
	void close(){}	// 关闭资源句柄
};

int main(){
	
	auto deletor = [](Socket* psocket){
		psocket->close();
		delete psocket;	// 删除堆内存
	};
	unique_ptr<Socket, void(*)(Socket* psocket)> spSocket(new Socket(), deletor);
	
	return 0;
}
```

自定义 **std::unique_ptr** 的资源释放函数其规则是：

```
std::unique_ptr<T, DeletorFuncPtr>
```

其中 T 是你要释放的对象类型，DeletorPtr 是一个自定义函数指针。也可以使用`decltype`关键字自行推断。

```c++
auto deletor = [](Socket* psocket){
    psocket->close();
    delete psocket;	// 删除堆内存
};
unique_ptr<Socket, decltype(deletor))> spSocket(new Socket(), deletor);
```

## 三、std::shared_ptr

### 1、初始化

```c++
shared_ptr<int> sp1(new int(8));

shared_ptr<int> sp2;
sp2.reset(new int(8));

shared_ptr<int> sp3;
sp3 = make_shared<int>(8);
```

### 2、引用计数

​	**std::unique_ptr** 对其持有的资源具有独占性，而 **std::shared_ptr** 持有的资源可以在多个 **std::shared_ptr** 之间共享，每多一个 **std::shared_ptr** 对资源的引用，资源引用计数将增加 1，每一个指向该资源的 **std::shared_ptr** 对象析构时，资源引用计数减 1，最后一个 **std::shared_ptr** 对象析构时，发现资源计数为 0，将释放其持有的资源。

​	多个线程之间，递增和减少资源的引用计数是安全的，即**引用计数是原子操作**。（注意：这不意味着多个线程同时操作 **std::shared_ptr** 引用的对象是安全的）。**std::shared_ptr** 提供了一个 **use_count()** 方法来获取当前持有资源的引用计数。除了上面描述的，**std::shared_ptr** 用法和 **std::unique_ptr** 基本相同。

### 3、`enable_shared_from_this`

​	`std::enable_shared_from_this` 能让一个对象（假设其名为 t ，且已被一个 `std::shared_ptr` 对象 pt 管理）安全地生成其他额外的 `std::shared_ptr` 实例（假设名为 pt1, pt2, ... ） ，它们与 pt 共享对象 t 的所有权。

​	若一个类 T 继承 `std::enable_shared_from_this<T>` ，则会为该类 T 提供成员函数： `shared_from_this` 。 当 T 类型对象 t 被一个为名为 pt 的 `std::shared_ptr<T>` 类对象管理时，调用 `T::shared_from_this` 成员函数，将会返回一个新的 `std::shared_ptr<T>` 对象，它与 pt 共享 t 的所有权。

```c++
#include <iostream>
#include <memory>
using namespace std;

class A: public enable_shared_from_this<A>{	// 继承
public:
	A(){}
	~A(){}
	shared_ptr<A> getSelf(){
		return shared_from_this();
	}
};

int main(){

	shared_ptr<A> sp1(new A());
	shared_ptr<A> sp2 = sp1->getSelf();

  return 0;
}
```

上述代码中，类 A 的继承 **std::enable_shared_from_this** 并提供一个 **getSelf()** 方法返回自身的 **std::shared_ptr** 对象，在 **getSelf()** 中调用 **shared_from_this()** 即可。

#### 3.1、不应该共享栈对象的 `this` 给智能指针对象

如以下代码：

```cpp
//其他相同代码省略...

int main()
{
    A a;

    std::shared_ptr<A> sp2 = a.getSelf();

    std::cout << "use count: " << sp2.use_count() << std::endl;

    return 0;
}
```

运行修改后的代码会发现程序在 `std::shared_ptr sp2 = a.getSelf();` 产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过 **shared_from_this()** 将该对象交由智能指针对象管理。切记：**智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）**。

#### 3.2、避免 `std::enable_shared_from_this` 的循环引用问题

如以下代码：

```c++
#include <iostream>
#include <memory>

class A : public std::enable_shared_from_this<A>
{
public:
    A(){
        m_i = 9;
        std::cout << "A constructor" << std::endl;
    }

    ~A(){
        m_i = 0;
        std::cout << "A destructor" << std::endl;
    }

    void func(){
        m_SelfPtr = shared_from_this();
    }

public:
    int m_i;
    std::shared_ptr<A>  m_SelfPtr;
};

int main(){
    {
        std::shared_ptr<A> spa(new A());
        spa->func();
    }
    return 0;	
}	// 程序输出"A constructor"但是没有析构提示消息出现，说明内存发生了泄露!
```

## 四、`std::weak_ptr`

​	**std::weak_ptr** 是一个不控制资源生命周期的智能指针，是对对象的一种**弱引用**，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助 **std::shared_ptr** 工作。

### `weak_ptr`的构造

​	**std::weak_ptr** 可以从一个 **std::shared_ptr** 或另一个 **std::weak_ptr** 对象构造，**std::shared_ptr** 可以直接赋值给 **std::weak_ptr** ，也可以通过 **std::weak_ptr** 的 **lock()** 函数来获得 **std::shared_ptr**。它的构造和析构不会引起引用计数的增加或减少。**std::weak_ptr** 可用来解决 **std::shared_ptr** 相互引用时的死锁问题（即两个**std::shared_ptr** 相互引用，那么这两个指针的引用计数永远不可能下降为 0， 资源永远不会释放）。

实例代码如下：

```c++
#include <memory>
#include <iostream>

using namespace std;

int main(){

	shared_ptr<int> sp1(new int(8));
	cout << "use count: " << sp1.use_count() << endl;	// use count: 1

	weak_ptr<int> sp2(sp1);
	cout << "use count: " << sp2.use_count() << endl;	// use count: 1

	weak_ptr<int> sp3 = sp1;
	cout << "use count: " << sp3.use_count() << endl;	// use count: 1

	weak_ptr<int> sp4 = sp2;
	cout << "use count: " << sp4.use_count() << endl;	// use count: 1
    
    cout << "use count: " << sp1.use_count() << endl;	// use count: 1

	return 0;
}
```

​	无论通过何种方式创建 **std::weak_ptr** 都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。

​	既然，**std::weak_ptr** 不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？**std::weak_ptr** 提供了一个 **expired()** 方法来做这一项检测，返回 true，说明其引用的资源已经不存在了；返回 false，说明该资源仍然存在，这个时候可以使用 **std::weak_ptr** 的 **lock()** 方法得到一个 **std::shared_ptr** 对象然后继续操作资源，以下伪代码演示了该用法：

```c++
// tmpConn_ 是一个std::weak_ptr<TcpConnection> 对象

if(tmpConn_.expired()) exit(-1);

std::shared_ptr<TcpConnection> conn = tmpConn_.lock();
if (conn){
    // 对conn进行操作
}
```

​	不能直接使用`std::weak_ptr`对象对引用资源进行操作。因为`std:weak_ptr`类没有重写`operator->`和`operator*`方法，因此不像`std::shared_ptr`或`std::unique_ptr`一样直接操作对象，同时`std::weak_ptr`类也没有重写`operator!`操作，因此也不能通过`std::wak_ptr`对象直接判断其引用的资源是否存在。

```c++
#include <memory>

class A{
public:
    void doSomething(){}
};

int main(){   
    
    std::shared_ptr<A> sp1(new A());
    std::weak_ptr<A> sp2(sp1);
    //正确代码
    if (sp1){
        //正确代码
        sp1->doSomething();
        (*sp1).doSomething();
    }
    //正确代码
    if (!sp1){
    }

    //错误代码，无法编译通过
    //if (sp2){
    //    //错误代码，无法编译通过
    //    sp2->doSomething();
    //    (*sp2).doSomething();
    //}

    //错误代码，无法编译通过
    //if (!sp2){
    //}

    return 0;
}
```

### `weak_ptr`的应用场景

**std::weak_ptr** 的应用场景，经典的例子是**订阅者模式或者观察者模式**中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。

```c++
class Subscriber{

};
class SubscribeManager{
public:
	void publish(){
		for (auto && iter: m_subscribers){
			if (!iter.expired()){
				//	给订阅者发送消息
			}
		}
		
	}
private:
	vector<weak_ptr<Subscriber>> m_subscribers;
};
```

## 五、智能指针的大小

`std::unique_ptr`大小等于裸指针的大小即`sizeof(std::unique_ptr) == sizeof(void*)*`，`std::share_ptr`和`std::weak_ptr`大小为裸指针的两倍。

```c++
#include <iostream>
#include <memory>
#include <string>

int main()
{
    std::shared_ptr<int> sp0;
    std::shared_ptr<std::string> sp1;
    sp1.reset(new std::string());
    std::unique_ptr<int> sp2;
    std::weak_ptr<int> sp3;

    std::cout << "sp0 size: " << sizeof(sp0) << std::endl;
    std::cout << "sp1 size: " << sizeof(sp1) << std::endl;
    std::cout << "sp2 size: " << sizeof(sp2) << std::endl;
    std::cout << "sp3 size: " << sizeof(sp3) << std::endl;

    return 0;
}
```

windows下64位结果分别为：8、8、4、8

linux下64位环境中结果为：16、16、8、16